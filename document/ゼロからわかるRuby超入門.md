# 📖ゼロからわかるRuby超入門
**<details><summary>CHAPTER 1 環境を作る</summary>**
ようこそ、Rubyプログラミングの世界へ。プログラムを書くためには、Rubyやエディターなどのツールを使います。これらのツールはあなたのプログラミングの支えになってくれるでしょう。この章では、Rubyやエディターのインストール方法とRubyプログラムの動かし方を説明します。
- 1-5 プログラムを書いて実行する
    
    ここでは、Rubyのプログラムを作成して、実行するまでの流れを解説します。最初にエディターでプログラムを書いて、コマンドプロンプトで実行するだけで、すぐに結果を確認できます。
    
    - プログラムを保存するフォルダを作る
        - ファイルは /Users/[ユーザー名]/rubybook に保存します。
        - ターミナルを起動して、mkdir rubybook と入力してフォルダを作ります。
        - フォルダが作成できたかを確認するために、open . と入力してreturnキーを押します。すると、Finderが開いてフォルダの確認ができます。
    - プログラムをファイルに保存する
        - Rubyのプログラムが書かれたプログラムは、.rbをファイル名の末尾につけるのが習慣です。また、Rubyではファイル名は全て小文字を使うことが一般的です。
        - Visual Studio Codeでは、メニューから「ファイル」→「名前をつけて保存」を選択する。
    - ターミナルでプログラムを保存したフォルダへ移動する
        - cd rubybook returnキーで保存されているフォルダに移動します。
        - ターミナルでは、プログラムファイルがあるフォルダへ移動してプログラムを実行します。
        - 現在いるフォルダのことをカレントディレクトリと言います(ディレクトリはフォルダの別の呼び方です)。
        - カレントディレクトリを移動させるにはcdコマンド(change directoryの略)を使います。
        - フォルダをキーボードから入力するのが大変な時は、フォルダをターミナルへドラッグアンドドロップすると簡単に入力できます。
    - ターミナルでプログラムを実行する
        - Rubyプログラムを実行するには、ターミナルで ruby ファイル名 と入力し、returnキーを押します。
    - 基本的なコマンド
        - ターミナルの世界ではRuby言語とは違う言語である Shell言語を使います。
        - `cd`:フォルダを移動 `cd` の後ろに半角スペースを入れ、フォルダ名を入力します。
            
            例) `cd rubybook`
            
            1つ上のフォルダへ移動する時は、フォルダ名に`..`を指定します。
            
        - `pwd`:現在のフォルダを表示。フォルダはスラッシュ(`/`)で区切られます。
            
            `pwd` return
            
            `/Users/[ユーザー名]/rubybook`
            
        - `ls`:ファイル一覧を表示
            
            `ls` return
            
        - `ruby`:Rubyのプログラムを実行する。
            
            Rubyのプログラムを実行します。プログラムファイルがあるフォルダへ移動してから、rubyに続けてプログラムファイルを指定して実行します。実行結果は次の行に出力されます。
            
            `ruby hi.rb` return
            
        - `control + c`:プログラムを強制的に終了する。
            
            Rubyのプログラムの実行時に何らかの理由でプログラムが終了しなくなった場合は、`control  + c`で強制的に終了できます。
            
    - COLUMN コマンドをラクラク入力
        - 上下カーソルキーでコマンド履歴を表示して、以前に実行したコマンドを再実行できます。また、途中まで入力した状態で`tab`を押すと、ファイル名やフォルダ名などを補完してくれます。</details>

**<details><summary>CHAPTER 2 かんたんなプログラムを書く</summary>**
プログラムを書くことで、様々な問題をコンピュータを使って解決することができます。難しい問題を解くプログラムは難しくなりがちですが、短いプログラムでも解ける問題はたくさんあるので、最初は短いプログラムから始めましょう。この章では、短い簡単なプログラムを使ってRubyとプログラミングの基礎を説明していきます。
- 2-1 計算する
    
    最初は、計算をするプログラムから始めましょう。整数や少数の計算をして画面に表示するプログラムを書いて実行し、算数の答えがプログラムから得られることを見ていきましょう。
    
    - 数値を表示する
        - 実行するには、ターミナルで`cd ファイル名`でプログラムが置いてあるフォルダへ移動して、`ruby ファイル名`でプログラムを実行する。
        - `puts`は、後ろに書いたものを画面に表示するメソッドです。メソッドは英語で方法や手段という意味で、ここでは「命令」と考えると分かりやすいです。
        - 1は整数オブジェクト、または単に整数と呼びます。オブジェクトは日本語では「もの」という意味で、Rubyの世界での「もの」がオブジェクトです。
    - 少数を計算する
        - `puts` `5 / 2`は、`2.5`にならずに`2`となります。これは、Rubyでは整数と少数は別のものとして扱われ、整数同士の計算の結果は整数になるルールだからです。余りの`0.5`は切り捨てられます。結果として`2.5`を得るためには、`.0`をつけて(両方または一方を)少数の計算にすればOKです。`5.0`や`2.0`は少数オブジェクト、または単に少数と呼びます。
    - 累乗と余剰を計算する
        - `puts 2 ** 8` —累乗。2の8乗。実行結果は「256」
            
            `puts 7 % 3` —剰余。7を3で割ったあまり。実行結果は「1」
- 2-2 文字列を表示する
    
    プログラムで文字を扱う時には文字列を使います。文字列はプログラムでよく使う部品の一つです。ここでは、文字列を表示したり、足し算を使って繋げる方法を説明していきます。
    
    - 文字列を表示する
        - `“hello world!”`は文字列オブジェクト、文字列と呼びます。文字の前後を”(ダブルクォーテーション)で囲むと文字列になります。
    - 文字列を足し算する
        - 数値と同じく、文字列は足すこともできます。
        - `2 + 3` は`5`、`”2” + “3”`は文字列を繋げた結果の`23`になっています。Rubyでは数値と文字列は別物として扱われるためです。数字をそのまま書くと数値、”で囲むと文字列と扱います。
    - 数値と文字列を足すとどうなる？
        - エラーが表示されます。Rubyではエラーが出ると、プログラムを意図通りに動かすヒントが書かれたメッセージが出ます。
            
            `error1.rb:1:in `+': String can't be coerced into Integer (TypeError) from error1.rb:1: in `<main>'`
            
            「error1.rb というファイルの1行目、String can’t be coerced into Integer(文字列は整数には変換できない)なので、TypeErrorです」となります。
            
    - 文字列を数値に変換する
        - 整数を文字列へ変換する、`to_s`メソッド、文字列を整数へ変換する`to_i`メソッドを使って、数値、文字列に揃える方法があります。
        - `to_s`は英単語のto(〜へ)とstring(文字列)の頭文字のsの組み合わせで、「文字列へ(変換)」という意味です。`to_i`のiはinteger(整数)の頭文字で、「整数へ(変換)」という意味です。
        - これらのメソッドはオブジェクトの後ろに.をつけて書きます。`3.to_s`は整数オブジェクト3を変換して文字列オブジェクト`”3”`を作ります。`”3”.to_i`は文字列オブジェクト`”3”`を変換して整数オブジェクト`3`を作ります。
        - 「オブジェクトに対して何かする」型のメソッドは大抵の場合、「`オブジェクト.メソッド`」形をとります。
- 2-3 オブジェクトと変数を理解する
    
    これまでにたびたび出てきた「オブジェクト」について説明します。また、オブジェクトに名札を付けることができる道具「変数」についても説明します。
    
    - オブジェクトとは
        - オブジェクトとは、Rubyの世界での「もの」です。プログラムの中でデータを持ったり、操作したりする対象です。`1`はオブジェクトです。詳しく言えば、整数オブジェクトです。`5.0`や`2.0`もオブジェクトで少数オブジェクトです。`”カフェラテ"`は文字列オブジェクトです。因みに、putsはメソッド(命令)と呼ばれる、別の種類です。
        - オブジェクトの種類のことをクラスと言います。例えば、整数オブジェクトはInteger(整数の意味)オブジェクトと呼ぶこともあり、このIntegerがクラスの名前です。同様に、少数オブジェクトはStringオブジェクトとも呼び、Stringがクラスの名前です。
    - 変数とは
        - 変数はオブジェクトにつける名札です。
        - `order = “カフェラテ”`は「変数orderに”カフェラテ”を代入する」と言います。イコール(=)の左側が変数、右側が代入するオブジェクトです。左右を逆にして書くことはできません。
        
        ```ruby
        order = "カフェラテ" # 文字列カフェラテを変数orderに紐付ける。
        puts order # カフェラテが表示される。
        ```
        
    - 文字列に計算結果を埋め込む
        - `#{計算式}`と書くことで、文字列に計算結果を埋め込んで表示できます。これを**式展開**と言います。計算式を文字列に展開する、という意味です。
        
        ```ruby
        puts "1 + 2の答えは#{1 + 2}です"
        # 1 + 2の答えは3です
        ```
        
        - 式展開(#{計算式})は、変数を使うこともできます。式展開に変数を書くことで、変数に代入されたオブジェクトを埋め込むことができます。
        
        ```ruby
        order = "カフェラテ"
        puts "ご注文は#{order}ですね？" # 式展開を使う書き方
        puts "ご注文は" + order + "ですね？" # 足し算を使う書き方
        ```
        
        このように、同じ結果を得るプログラムでも、さまざまな書き方があります。式展開には変数のほか、さまざまなRubyのプログラムを埋め込むこともあります。
        
    - 変数の名前のルールを確認する
        - 変数の名前には原則として、英字、数字、_(アンダーバー、アンダースコア)を使います。ただし、先頭は英字小文字または_で始める必要があります。
        - 慣習では、英字は全て小文字で書き、2単語以上繋げる時は_を間に入れます。`my_order`、`my_favorite_order`といった具合です。このスタイルを**スネークケース**と言います。
        - プログラムの読み手を思い浮かべて、意味のある、良い名前をつけた方がプログラムは読みやすくなります。ここでの読み手は、自分も含まれます。
        
        ```ruby
        良い例: order , x1
        悪い例: Order , ORDER , 1x
        ```
        
    - キーボードから値を入力する
        - `gets`メソッドは、ターミナル上から値を入力するプログラムを書くことができます。そして、入力された文字列を整数での計算にするために`to_i`メソッドを使います。
    - COLUMN 定数とは
        - 定数という仕組みがあります。定数は、変数のように代入ができますが、2回目に代入しようとするとwarningが出ます。
        
        ```ruby
        CaffeLatte = "カフェラテ" # CaffeLatteは定数。1回目の代入。
        puts CaffeLatte
        CaffeLatte = "カフェラッテ" # 定数CaffeLatteへ2回目の代入。warningが表示する。
        puts CaffeLatte
        ```
        
        ```ruby
        カフェラテ
        const.rb:3: warning: already initialized constant CaffeLatte
        const.rb:1: warning: previous definition of CaffeLatte was here
        カフェラッテ
        ```
        
        - warningは好ましくない処理をする時にメッセージを表示し、渋々実行してくれるものです。定数は固定しておくものなので、変更しようとすると「意図通りですか？」とwarningが表示されて教えてくれるというわけです。warningが表示されますが、代入は実行されます。
        - 先頭が大文字の名前をつけると、定数になります。2文字目以降は小文字も大文字も使えます。
    - 📍**まとめ**
        - オブジェクトは、Rubyの世界での「もの」。
        - オブジェクトには文字列オブジェクト、整数オブジェクト、少数オブジェクトなどがある。
        - 変数はオブジェクトに貼る名札で、名札を貼ることを変数へ代入するという。
        - 変数が使われる時は、先にその変数に代入しておいたオブジェクトとして扱われる。
        - 変数名の先頭は英字小文字または_で始め、英字、数字、_を使うことができる。
        - #{計算式}と書くことで計算結果を文字列の中に埋める。
- 2-4 プログラムにコメントを書く
    
    将来プログラムを読んだ時のために、理解を助ける説明文を書いておくと便利なことがあります。プログラムの中に説明を書くことができるコメントについて説明します。
    
    - 行の途中からコメントにする
        - **#**は行の先頭だけでなく、行の途中から書くこともできます。行の途中から書いた場合、#よりも後ろに描かれた部分がコメントとなり、実行されなくなります。
    - 空行は無視される
        - プログラムには読みやすくするための区切りとして空行が使えますが、実行する時には空行は無視されます。
    - 数行にわたってコメントにする
        - 長い行をまとめてコメントにする場合、各行頭に#を書くのが大変な時もあります。その場合は、`=begin`から`=end`で囲むと、その範囲はコメントとして扱われます。書く時は、行の先頭から書く必要があるので注意してください。
        
        ```ruby
        puts 1
        =begin
        puts 2
        puts 3
        puts 4
        =end
        ptus5
        ```
        
        ```ruby
        1
        5
        ```
        
    - 📍**まとめ**
        - #から書き始めた行はコメントになる。
        - コメントはプログラムとして実行されない。
        - #は行の途中にも書くことができ、その後ろがコメントになる。
        - 空行は無視される。
- 2-5 対話的に実行する
    
    ここまでは、プログラムが書かれたファイルをRubyに渡して、まとめて実行させていました。こうしたやり方のほかに、入力したプログラムを1行ずつその場ですぐに実行させることができるirbという道具もあります。irbを使うと、1行ずつ結果を見ながらプログラムを実行していくことができます。
    
    - irbの使い方
        - 入力したプログラムを1行ずつその場ですぐに実行させることができるirbという道具があります。
        
        ```ruby
        irb(main):001:0> x = 2
        => 2
        irb(main):001:0> x
        => 2
        irb(main):001:0> x * 3
        => 6
        ```
        
        - irbを終了する場合はexitと入力してreturnキーを押します。
        
        ```ruby
        irb(main):001:0> exit
        ```
        
        - 終了すると、元のターミナルへ戻ります。irbの世界ではRuby言語を話し、ターミナルの世界ではshell言語を話します。違う世界の言語で命令しても、言葉が通じないのでうまく動きません。以下は、うまく動かない例です。
        
        ```ruby
        x = 2 # Ruby言語をコマンドプロンプト(shell言語)の世界で実行しようとしている
        sh: command not found: x # エラー
        ```
        
    - プログラムの途中で一時停止してirbを使う
        - irbには、プログラムの途中で一時停止して起動する方法もあります。
        
        ```ruby
        a = 1
        binding.irb
        puts a
        ```
        
        ```ruby
        From: birb.rb @ line 2 :
        
        		1:  a = 1
        =>  2: binding.irb
        		3: puts a
        
        irb(main):001:0>
        ```
        
        ```ruby
        irb(main):001:0> a = 2 # 変数aへ2を代入
        => 2
        irb(main):001:0> exit
        2 # プログラムが再開し、その後の行のputs aが実行されると、irbで代入した変数aの値が表示される
        ```
        
        - プログラム中でirbを使うためにはbinding.irbをプログラムの実行を一時停止したい場所へ書きます。この機能は、プログラムの間違いを見つけて直すのにも便利です。
    - 📍まとめ
        - irbを使うと1行ずつ入力したプログラムをその場ですぐに実行できる。
        - irbを終了する場合はexitと入力してreturnキーを押す。
        - irbはRuby言語を話す世界、コマンドプロンプトはshell言語を話す世界。
- 2-6 プログラムの間違いを見つけて直す
    
    プログラムを書いて一度でうまく動かすのは簡単ではありません。プログラムが意図通り動いているかを確かめ、間違えている部分(バグ)を見つけて直していくことをデバッグと言います。プログラミングの作業で重要な工程の一つです。
    
    - pメソッドを使って変数の中身を表示させる
        - pメソッドは後ろに書いた変数やオブジェクトを画面に表示するメソッドです。putsメソッドと似た機能で、デバッグの機械に使われます。何より1文字で短いので書くのが簡単です。
        
        ```ruby
        a = 3 / 2
        p a # ①
        b = a * 2
        puts b
        ```
        
        ```ruby
        1 # ②
        2
        ```
        
        - ①の行でpメソッドを使って変数aを表示させました。実行結果を見ると、1.5ではなく、1が表示されています。これは、整数/整数の計算結果は小数点以下が捨てられて整数になるためです。変数aに1.5を代入するには、3か2のどちらか、または両方を少数にすることで計算結果も少数になります。
        - **pメソッド**は、原則、デバッグの道具として使う。**putsメソッド**は、プログラムの機能として意図して表示する時に使う。
    - 📍まとめ
        - pメソッドは後ろに書いた変数やオブジェクトを表示する。
        - pメソッドは原則、デバッグの道具として使う。
- 2-7 エラーメッセージを読み解く
    
    この節では実際にエラーを起こして、そのときのメッセージの読み方と対応方法を説明します。ここでいろんなエラーに対応する経験を積んでおきましょう。エラーが起こった時の対応はP.40でも説明しているので、あわせて参考にしてください。
    
    - エラーメッセージの読み方
        - エラーが起きてもプログラムを修正して、意図した動きに少しずつ近づけていくのが普通のプログラミングの流れです。
        
        ```ruby
        put "hi"
        ```
        
        ```ruby
        Traceback (most recent call last):
        hi.rb:1:in `<main>': undefined method `put' for main:Object
        	(NoMethodError)
        Did you mean?  puts
        								putc
        ```
        
        - hi.rbは実行したファイル名。
        - 1はプログラムの何行目でエラーが起きたのかを教えてくれます。
        - in `<main>':は今回、得られる情報が少ないので説明を省略。
        - undefinde method `put' for main:Objectはエラーメッセージの本文です。undefinde method `put'は「定義されていないメソッド`put'」となり、「putメソッドを実行しようとしたが、定義(用意)されていないので困りました」というRubyからのメッセージです。
        - NoMethodErrorがエラーの名前で、メソッドが用意されていない時起きるエラーです。
        - まとめると、「1行目に書かれたputメソッドは定義されていません」という意味になります。
        - Did you mean?以降はRubyからの提案が書かれています。「Did you mean?」は「もしかして？」という意味です。後ろに書かれたputsとputcがRubyからの提案です。エラーメッセージ全体では以下のようになります。
        
        ```ruby
        「hi.rbの1行目に書かれたputメソッドは定義されていません。もしかして、putsやputcではないですか？」
        ```
        
        - エラーメッセージを読み解くことは、デバッグをする上で基礎となる重要な技術です。
    - いろいろなエラーメッセージを体験する
        - 変数の名前を間違えた:変数xに1を代入して、それを表示するプログラムを書くところ、間違えて変数yを表示しようとしたケースです。
        
        ```ruby
        x = 1
        p y
        ```
        
        ```ruby
        Traceback (most recent call last):
        xy.rb:2:in `<main>': undefined local variable or method `y' for
        	main:Object (NameError)
        
        # xy.rbの2行目でエラーが発生しました。undefined local variable or method `y'(定義されていない変数またはメソッド'y'です。NameError(名前エラー)です。
        ```
        
        - 0で割り算した:0で割り算をするとエラーが発生します。
        
        ```ruby
        p 1 / 0
        ```
        
        ```ruby
        Traceback (most recent call last):
        				1: from 0div.rb:1:in `<main>'
        0div.rb:1:in `/': divided by 0 (ZeroDivisionError)
        
        # 0dir.rbの1行目でエラーが発生しました。divided by 0(0での割り算)です。ZeroDivisionError(0除算エラー)です。
        ```
        
        - 実行するファイル名が違う:abc.rbをじっこうしようとしてab.rbという存在しないファイルを指定したときのエラーです。
        
        ```ruby
        puts "abc"
        ```
        
        ```ruby
        Traceback (most recent call last):
        ruby: No such file or derectory -- ab.rb (LoadError)
        
        # No such file or directory(このようなファイルやフォルダはない)です。ab.rbというファイルです。LoadError(読み込みエラー)です。
        ```
        
    - 📍まとめ
        - エラーメッセージはRubyからプログラマーである私たちへのさまざまなヒント。
        - エラーメッセージには実行しているファイル名、行番号、エラーの種類と内容、修正候補の情報がある。</details>

**<details><summary>CHAPTER 3 処理の流れを変える</summary>**
ここまでのプログラムは1本道で順番に実行していくものでした。プログラムは条件によって分岐し、異なる処理を実行することができます。この章では、条件を判断する方法と、それによって処理を分岐する方法を説明します。また、同じ処理を繰り返す方法も説明します。

条件分岐も、繰り返しも、よく使われる便利な部品なので、これらを使うとプログラムで解決できる問題の範囲がぐっと広がります。
- 3-1 条件を判断する
    
    今までのプログラムは決まった処理を決まった順で進んでいく、一本道のプログラムでした。次は、プログラムを条件によって分岐させます。この節で説明する条件を判断する方法と、次の節のifをあわせて使うと、条件によって処理を実行する・しないを切り替えることができます。
    
    - 大きさを判断する
        - 比較メソッドは<と>に加えて、等しい時にも条件を満たす比較メソッド<=や>=もあります。算数での≤と≥に相当します。>=のように>を先に書くことに注意してください。=>のように先に＝を書いたものは、他の意味で使われているため、今回の意図では使えません。
    - 等しいことを判断する
        - 等しいかどうかを判断する比較メソッドは、Rubyでは「`=`」を2つ繋げて「`==`」と書きます。これは、前に出てきた「変数への代入」の機能として「=」が使われているためです。
        - 等しくない時にtrueを返す「`!=`」もあります。算数での「≠」に相当します。
        - 「`==`」や「`!=`」は、数値オブジェクトだけでなく、文字列オブジェクトを比較することもできます。
    - COLUMN 末尾に?がつくメソッド
        - どきどき末尾に?がつくメソッドがあります。例えば、even?メソッドは偶数かどうかを判断してtrueかfalseを返します。また、奇数かどうかを判断するodd?メソッドもあります。慣習的に、末尾に?がつくメソッドはtrueかfalseのどちらかを返すことが多いです。
- 3-2 条件を満たしたときに処理をする
    
    前節では、条件を判断する方法を学びました。次は、条件によって実行する処理を変えるifを説明します。この2つを組み合わせることで、条件によって分岐するプログラムを書くことができます。
    
    - if - 条件を満たす時
        - if
        
        ```ruby
        if 条件
        	条件が成立したときの処理
        end
        ```
        
        ```ruby
        wallet = 500 # ①
        if wallet >= 300 # ②
        	puts "コンビニでアイスを買っていこう！" # ③
        end # ④
        ```
        
        ②〜④の行までがif式です。④のendはここまで、とif式を終わらせる合図です。条件を満たした時に実行する処理は、「ifの次の行」から「endの前の行」までに書きます。
        
        ③のputsの行は先頭にスペースが入って一段下がっていることに注意してください。この段のことを「**インデント**」、一段下げることは「**インデントを下げる**」言います。条件を満たした時に実行するプログラムは、インデントを一段下げる習慣になっています。
        
        - インデント一段のスペースの数は、2個にすることが多いです。
        - **インデントはプログラムを読みやすくするもので、自分を含めたプログラマーへの思い遣りなのです。**
    - COLUMN **後置if(if修飾子)**
        - 後置ifを使うと、ifからendまで複数行で書いたプログラムを1行で書くことができます。後置ifではendを書く必要がありません。条件を満たしたときの処理が1行に収まる時に使うと、プログラムを短く読みやすく書くことができます。
    - unless と !
        - 「等しくない」は`!=`のほかに、ifと反対の働きをする`unless`を使って書くこともできます。`unless` は条件を満たさない時に処理を実行します。条件を満たす時は何も実行しません。
        - また、`unless`は`if`と同じように、高知で書くこともできます。上手に使うとプログラムを読みやすく書くことができます。
        - trueとfalseを反転する`!`もあります。`!`は変数やオブジェクトの前に書きます。
    - 📍まとめ
        - ifは条件を満たした時に処理を実行し、条件を満たさない時は処理を実行しない。
        - ifの条件を満たした時は、ifの次の行からendの前の行までの処理が実行される。
        - ifの条件を満たさない時は、endまでの処理は実行されずendの次の行へ進む。
        - 条件を満たしたときの処理は、インデントを下げて書く。
        - 条件はfalseまたはnilとなる時に満たされず、それ以外は条件を満たす。
        - unlessは条件を満たさない時に処理を実行し、条件を満たした時は処理を実行しない。
- 3-3 条件を満たさないときにも処理する
    
    前節では、ifを使うと条件を満たした時に処理を実行させることができることを学びました。今度は、条件を満たした時、満たさない時の二つに分岐させて、それ煽れ違う処理をさせるプログラムを書いてみましょう。
    
    - 条件を満たさないときの処理 - else節
        - else
        
        ```ruby
        if 条件
        	条件を満たしたときの処理
        else
        	条件を満たさなかったときの処理
        end
        ```
        
        ```ruby
        wallet = 100
        if wallet >= 300
        	puts "コンビニでアイスを買っていこう！"
        else
        	puts "川沿いを散歩しよう！"
        end
        
        # 川沿いを散歩しよう！
        ```
        
        ```ruby
        wallet = 100
        if wallet >= 300
        	puts "コンビニでアイスを買っていこう！"
        else
        	puts "川沿いを散歩しよう！"
        end
        
        # コンビニでアイスを買っていこう！
        ```
        
    - elsif と、組み合わせた if
        - `elsif`は複数書くことも可能ですが、書きすぎると読みづらくなることもあります。そのような場合は、書き換えで登場したifを組み合わせたプログラムを使ったり、`&&`、`||`、`case`を使って読みやすく書けないか、も検討してみてください。
        - **読みやすいプログラムは、意味が頭に入ってきます。**
        
        ```ruby
        season = "夏"
        if season == "春"
        	puts "アイスを買っていこう！"
        elsif season == "夏"
        	puts "かき氷買ってこう！"
        else
        	puts "あんまん買ってこう！"
        end
        
        # "かき氷買ってこう！"
        ```
        
        ```ruby
        season = "夏"
        if season == "春"
        	puts "アイスを買っていこう！"
        else
        	if season == "夏"
        		puts "かき氷買ってこう！"
        	else
        		puts "あんまん買ってこう！"
        	end
        end
        
        # "かき氷買ってこう！"
        ```
        
    - 📍まとめ
        - if else節を使うと、条件を満たす、満たさないによって、それぞれの処理を実行させることができる。
        - ifの条件を満たした時は、ifの次から、elseの前の行までの処理が実行される。
        - ifの条件を満たさない時は、elseの次から、endの前の行までの処理が実行される。
        - ifやelseで実行する処理は、インデントを下げて書く。
- 3-4 複数の条件を組み合わせる
    
    「現金か、またはSuicaで300円持っていたらアイスを買おう」といったように、複数の条件を組み合わせて使うことは日常でもよくあるケースです。ここでは複数の条件によって分岐するプログラムを書いてみましょう。
    
    - どちらかの条件を満たす時 - 「aまたはb」
        - 「または」を書くには`||`という記号を使います。「または」や「オア」と呼んでいます。
        - 「または」で複数の条件を書く時は次のようになります。
        - `||`(または、オア)
        
        ```ruby
        if 条件1 || 条件2
        	条件を満たしたときの処理
        end
        ```
        
        ```ruby
        wallet = 100
        suica = 300
        if wallet >= 300 || suica >= 300
        	puts "コンビニでアイスを買っていこう！"
        end
        
        # コンビニでアイスを買っていこう！
        ```
        
        条件1、条件2のどち⌃かを満たすと、条件を満たしたときの処理が実行されます。両方の条件を満たす時も、条件を満たしたときの処理が実行されます。
        
        - 3つ以上の条件を繋ぐこともできます。
        
        ```ruby
        if 条件1 || 条件2 条件3
        ```
        
    - 両方の条件を満たすとき - 「aかつb」
        - 「かつ」を書くには`&&`という記号を使います。「かつ」や「アンド」と呼んでいます。
        - `&&`(かつ、アンド)
        
        ```ruby
        if 条件1 && 条件2
        	条件を満たしたときの処理
        end
        ```
        
        条件1、条件2の両方を満たすとき、条件を満たしたときの処理が実行されます。
        
        ```ruby
        wallet = 500
        weather = "fine"
        if wallet >= 300 && weather == "fine"
        	puts "コンビニでアイスを買っていこう！"
        end
        
        # コンビニでアイスを買っていこう！
        ```
        
        - `&&`も3つ以上の条件を繋ぐこともできます。
    - ifの条件に書けるもの
        
        ```ruby
        if 100
        	puts "100で成立しました"
        end
        if "abc"
        	puts "abcで成立しました"
        end
        ```
        
        ```ruby
        if_experiment.rb:6: warning: string literal in condition
        100で成立しました
        abcで成立しました
        ```
        
        - ifの条件を満たすルールは「条件がfalseまたはnilは条件を満たさず、それ以外は条件を満たす」。
        - if_experiment.rb:6: warning: string literal in conditionはwarningメッセージです。ifの条件(condition)に文字列(string literal)が書かれていることは意図通りであるか、確認を促すメッセージです。
    - 📍まとめ
        - 「aまたはb」は`a || b`と書く。どちらか一方でも満たせば条件を満たす。
        - 「aかつb」は`a && b`と書く。両方を満たせば条件を満たす。
- 3-5 複数の道から1つを選んで分岐する
    
    注文がカフェラテ、モカ、コーヒーのいずれかでそれぞれ別の処理をしたい、そんなばめんをぷろぐらむにしていきます。caseを使うと複数の道から1つを選ぶプログラムを書くことができます。
    
    - 複数の道から1つを選んで分岐する - `case`
        - 条件によって分岐させる方法には、ifのほかに`case`もあります。`case`は条件によって複数の道から1つ選んで分岐する時に使います。
        - `when`の候補は、いくつでも書くことができます。もしも複数の候補と合致するときは、最初に合致したwhen節のみ処理を実行します。また、いずれの候補とも合致しなければ、何も実行しません。
        - `case`
        
        ```ruby
        case 変数
        when 候補1
        	変数の値が候補1と等しいときの処理(複数行書くこともできる)
        when 候補2
        	変数の値が候補2と等しいときの処理(複数行書くこともできる)
        (以下、候補をさらに追加できる)
        end
        ```
        
        ```ruby
        order = "モカ"
        case order
        when "カフェラテ"
        	puts "300円です"
        when "モカ"
        	puts "350円です"
        end
        
        # 350円です
        ```
        
    - 複数の道に合致するものがないときの処理を書く
        - caseは、どの候補とも合致しない時に実行するelse節を書くこともできます。
        - caseは、「1つの変数の値に応じて、複数の処理から1つを選んで実行する」時に便利な書き方です。
        - 二択の時は`if`、三択以上の時は`case`から考えると良いでしょう。
    - COLUMN caseの後に変数を書かない使い方もある
        - caseには、ほかにも便利な使い方があります。caseの後に変数を書かず、whenのあとにifの条件と同じように条件などを書く使い方です。この使い方では、一致以外の条件を書くこともできます。
        
        ```ruby
        wallet = 300
        case
        when wallet >= 500
        	puts "モカにホイップトッピング"
        when wallet >= 300
        	puts "カフェラテ"
        end
        ```
        
        ```ruby
        カフェラテ
        ```
        
        when節の条件を先頭のwhenから順に判定して、最初に条件を満たした箇所の処理を行います。
        
    - 📍まとめ
        - `case`は「変数の値に応じて、複数の道から1つを選んで分岐する」処理。
        - 二択の時は`if`から、三択以上の時は`case`から考えると良い。
- 3-6 なんども繰り返す
    
    ここでは、新しい機能である「繰り返し」を説明します。繰り返しはコンピュータの得意技です。人間と違って疲れることなく、何度でも正確に処理を繰り返すことができます。繰り返しはプログラムの中で最もよく使う機能の一つです。繰り返しを使いこなせば、機械仕掛けの時計のような小気味よいプログラムを書くことができます。ここでは、回数を指定して繰り返すプログラムを説明をします。
    
    - 決まった回数だけ繰り返す - timesメソッド
        - `do`と`end`のセットは「ブロック」と呼ばれる、処理のかたまりを書ける部品です。`do`の次の行から`end`の前の行まで繰り返し実行する処理を書きます。
        - **ブロックの中はインデントを1つ下げて書きます**。ブロックでは`do`を書くことに気を付けてください。
        
        ```ruby
        3.times do # ①
        	puts "カフェラテ" # ②
        end # ③
        ```
        
        ```ruby
        カフェラテ
        カフェラテ
        カフェラテ
        ```
        
        ①の3.times doの行から繰り返し処理が始まり、繰り返し処理の実行内容は②のputs “カフェラテ”。③のendに到達すると①のdoに戻って繰り返し処理を実行。といった流れとなる。
        
        - ブロックには、複数行の処理を書くこともできます。
        - プログラムは重複がないように書いておいた方がメリットは多いのです。重複を避けてプログラムを書く習慣を`DRY`と言います。`Don’t Repeat Yourself`の頭文字です。**DRYなプログラムを心掛けることで、読みやすく、メンテナンスしやすいプログラムになります**。
        - n.times do
        
        ```ruby
        n.times do
        	繰り返し実行する処理
        end
        ```
        
    - `do end`の代わりに`{}`を使う
        
        ```ruby
        3.times {
        	puts "カフェラテ"
        }
        ```
        
        ```ruby
        カフェラテ
        カフェラテ
        カフェラテ
        ```
        
        - また、ブロックは1行で書くこともできます。
        
        ```ruby
        3.times do puts "モカ" end
        3.times { puts "カフェラテ" }
        ```
        
        ```ruby
        モカ
        モカ
        モカ
        カフェラテ
        カフェラテ
        カフェラテ
        ```
        
        - 慣習的に、ブロックを複数行で書く時は`do`と`end`を使い、1行で書く時は`{`と`}`を使うことが多いです。
        
        ```ruby
        3.times do
        	puts "モカ"
        	puts "ください"
        end
        3.times { puts "カフェラテください" }
        ```
        
        ```ruby
        モカ
        ください
        モカ
        ください
        モカ
        ください
        カフェラテください
        カフェラテください
        カフェラテください
        ```
        
    - 条件付き繰り返し while
        - n.`time`と違い、`do`を書かないことに気を付けてください。`while`はブロックを使わずに、`while`と`end`のセットを使います。
        - `while`
        
        ```ruby
        while 条件
        	条件を満たしている間、繰り返し実行する処理
        end
        ```
        
        ```ruby
        biscuit = 0
        while biscuit < 2 # ①繰り返す条件
        	biscuit = biscuit + 1 # ③変数biscuitの値に1を加えて再度代入する
        	puts "ポケットを叩くとビスケットが#{biscuit}つ"
        end # ②
        ```
        
        ```ruby
        ポケットを叩くとビスケットが1つ
        ポケットを叩くとビスケットが2つ
        ```
        
    - 📍まとめ
        - n.timesに続いて繰り返し処理のブロックを書く。
        - ブロックはdoからendまでのプログラムのかたまり。
        - n.timesと書くとブロックないの処理をn回繰り返し実行する。</details>

**<details><summary>CHAPTER 4 まとめて扱う - 配列</summary>**
メニューに並んだ商品、コーヒー豆の瓶の列、作られるのを待っている注文群。例えばこんなカフェの場面のように、日常には「まとめられているものたち」がたくさんあります。Rubyでは「まとめられているもの(オブジェクト)たち」扱うために「配列」という部品が用意されています。
- 4-1 オブジェクトをまとめて扱う
    
    メニューにはカフェラテ、モカ、コーヒー。オーダーの入った注文はケーキ、アイス、サンドイッチ。こんな風に、バラバラで扱うよりもまとめて扱った方が便利な場面があります。Rubyでは「まとめられているもの(オブジェクト)たち」を扱うために、「配列」という部品が用意されています。まずは配列とはどんなものなのか？からみていきましょう。
    
    - 配列とは
        - **配列はオブジェクトをまとめて扱う部品**です。
        
        ```ruby
        # 例
        ["カフェラテ", "モカ", "コーヒー"}
        ```
        
        - 数値や文字列と同じように、配列自身もオブジェクトです。オブジェクトの種類のことをクラスをいいます。整数クラスは`Integer`、少数クラスは`Float`、文字列クラスは`String`でした。配列のクラス名は`Array`です。`Array`は**配列という意味の英単語**です。**配列のことを、配列オブジェクト、Arrayオブジェクト、あるいはそのまま配列と呼びます**。
    - 配列を作る
        - 配列は[で始まり、]で終わります。[と]の間にカンマ区切りで複数のオブジェクトを書くことができます。**配列の中身である個々のオブジェクトを要素と呼びます**。
        
        ```ruby
        # 例えば
        ["カフェラテ", "モカ", "コーヒー"]は3つの要素 "カフェラテ"と"モカ"と"コーヒー"を持っています。
        ```
        
        ```ruby
        p ["カフェラテ", 400, 1.08] # 文字列オブジェクト、整数オブジェクト、少数オブジェクトが入った配列
        p [300] # 要素が1つの配列
        p [] # 要素が1つもない空の配列
        ```
        
        ```ruby
        ["カフェラテ", 400, 1.08]
        [300]
        []
        ```
        
        - 配列へさらに新しい要素を追加することもできます⌃、配列から要素を削除することもできます。
        
        - 種類の違うオブジェクトを1つの配列に入れることもできます。
        - pメソッドは後ろに書いた変数やオブジェクトを画面に表示するメソッドです。
        - `配列`
        
        ```ruby
        [オブジェクト1, オブジェクト2, ......]
        ```
        
    - 変数に代入して配列に名前をつける
        - 変数に代入して配列に名前をつけてみましょう。変数への代入は、他のオブジェクトの時と同じく、配列オブジェクトに名札をつけるイメージです。
        
        ```ruby
        drinks = ["カフェラテ", "モカ", "コーヒー"]
        p drinks
        ```
        
        ```ruby
        ["カフェラテ","モカ","コーヒー"]
        ```
        
        このプログラムでは変数drinksに配列["カフェラテ", "モカ", "コーヒー"]を代入しています。言い換えると、配列["カフェラテ", "モカ", "コーヒー"]にdrinksという名前をつけているとも言えます。言い方は「配列drinks」と表記します。
        
    - COLUMN 配列を代入する変数名は複数形にする
        - 前のプログラムでは、変数にdrinksと英単語の複数形を使っています。これは、**配列を代入する変数は複数形にする習慣があるためです**。配列の変数は、次の例のように複数形で名付けます。
        
        ```ruby
        sugars = ["白砂糖", "黒糖", "角砂糖"]
        coffee_beans = ["Brazil", "Kenya", "Nicaragua"]
        even_numbers = [2, 4, 6] # even number:偶数
        ```
        
    - 📍まとめ
        - 配列は複数のオブジェクトをまとめて扱う道具。
        - 配列は`[`で始まり、`]`で終わり、カンマ区切りで複数の要素を書くことができる。
        - 種類の違うオブジェクトを1つの配列へ入れることもできる。
        - `[]`は空の配列。
- 4-2 要素を取得する
    
    前の節で配列の作り方を学びました。次は配列の要素を取得する方法を見ていきましょう。
    
    - 配列の要素を取得する
        - 配列の要素を取得する時には、後ろから数えることもできます。**後ろから数える時は、マイナスの数を使います**。
        
        ```ruby
        # 一番後ろの要素が -1番目
        # その前が       -2番目
        
        drinks = ["コーヒー", "カフェラテ”]
        puts drinks[-1] #=> "カフェラテ"
        puts drinks[-2] #=> "コーヒー"
        ```
        
        ```ruby
        カフェラテ
        コーヒー
        ```
        
        - よく使われる配列の先頭と末尾の要素を取得するために、firstメソッドとlastメソッドが用意されています。**firstメソッドは[0]と同じで先頭の要素を取得**し、**lastメソッドは[-1]と同じで末尾の要素を取得**します。
        
        ```ruby
        drinks = ["コーヒー", "カフェラテ"]
        puts drinks.first #=> "コーヒー"
        puts drinks.last #=> "カフェラテ"
        ```
        
        ```ruby
        コーヒー
        カフェラテ
        ```
        
        - **メソッドを実行することをメソッドを呼び出す**ともいいます。
        - 尚、これらの配列を操作するメソッドは、`drinks.first`のように変数名の後ろにドット(`.`)を付けて書きます。
    - 「何もない」ことを表すオブジェクト `nil`
        
        ```ruby
        drinks = ["コーヒー", "カフェラテ"]
        p drinks[2]
        ```
        
        ```ruby
        nil
        ```
        
        - 配列・rinksの要素は2個なので、drinks[0]、drinks[1]には対応する要素がありますが、drinks[2]にはありません。drinks[2]を使おうとすると、`nil`というものが返ってきます。
        - `nil`は、**「何もない」ことを表すオブジェクト**です。配列に対して、対応する要素がない場所から取得するとnilオブジェクトが返ります。また、nilオブジェクトは配列以外でも使われるので、この後もたびたび登場します。
    - COLUMN 変数を使わずにメソッドを呼び出す
        - drinks.firstのように変数に対してメソッドを呼び出すだけでなく、オブジェクトに対して直接メソッドを呼び出すこともできます。同じオブジェクトへのメソッド呼び出しであればどちらも同じ結果が得られます。
        
        ```ruby
        drinks = ["コーヒー", "カフェラテ"]
        p drinks.first #=> "コーヒー" # 変数に対してメソッドを呼び出す
        p ["コーヒー", "カフェラテ"].first #=> "コーヒー" # 配列オブジェクトへ直接メソッドを呼び出す
        ```
        
        - 変数を使わずに直接メソッドを呼び出すやり方は配列に限りません。
    - 📍まとめ
        - 配列は[n]や[-n]で要素を取得することができる。
        - nは先頭から数える時は0始まり、末尾から数える時は-1始まり。
        - 配列の先頭はfirstメソッド、末尾はlastメソッドでも取得できる。
        - 配列の存在しない場所から要素を取得しようとするとnilオブジェクトが返る。
        - nilオブジェクトは「何もない」ことを表すオブジェクト。
- 4-3 要素を追加・削除する
    
    ここまでで出てきたプログラムは、配列を作った後は要素の数が変わらないものでした。次は作った配列に後から要素を追加したり、削除したりしてみましょう。
    
    - 要素を追加する
        - 配列の末尾へ追加するには、`push`メソッド、先頭へ追加するには`unshift`メソッドを使います。
        
        ```ruby
        drinks = ["コーヒー"]
        drinks.push("カフェラテ") # ①配列の末尾に"カフェラテ"を追加
        p drinks #=> ["コーヒー", "カフェラテ"]
        drinks.unshift("モカ") # ②配列の先頭に"モカ"を追加
        p drinks #=> ["モカ", "コーヒー", "カフェラテ"]
        drinks << "ティーラテ" # ③配列の末尾に"ティーラテ"を追加
        p drinks #=> ["モカ", "コーヒー", "カフェラテ", "ティーラテ"]
        ```
        
        ```ruby
        ["コーヒー", "カフェラテ"]
        ["モカ", "コーヒー", "カフェラテ"]
        ["モカ", "コーヒー", "カフェラテ", "ティーラテ"]
        ```
        
    - 要素を削除する
        - 要素を削除する方法は2種類あります。
        
        ```ruby
        popメソッド:配列の末尾から要素を1つ削除する。
        shiftメソッド:配列の先頭から要素を1つ削除する。
        ```
        
        ```ruby
        drinks = ["モカ", "コーヒー", "カフェラテ"]
        drinks.pop # 配列の末尾から要素を1つ削除
        p drinks #=> ["モカ", "コーヒー"]
        drinks.shift # 配列の先頭から要素を1つ削除
        p drinks #=> ["コーヒー"]
        ```
        
        ```ruby
        ["モカ", "コーヒー"]
        ["コーヒー"]
        ```
        
        - `pop`メソッドと`shift`メソッドは、**削除した要素を返します**。**shiftメソッドは配列の最初の要素、popメソッドは配列の最後の要素をそれぞれ削除して、削除した要素を返します**。
        
        ```ruby
        drinks = ["モカ", "コーヒー", "カフェラテ"]
        p drinks.pop #=> "カフェラテ"
        p drinks.shift #=> "モカ"
        ```
        
        ```ruby
        "カフェラテ"
        "モカ"
        ```
        
    - 配列を足し算する
        
        ```ruby
        a1 = [1, 2, 3]
        a2 = [4, 5]
        p a1 + a2
        ```
        
        ```ruby
        [1, 2, 3, 4, 5]
        ```
        
    - 配列を引き算する
        
        ```ruby
        a1 = [1, 2, 3]
        a2 = [1, 3, 5]
        p a1 - a2
        ```
        
        ```ruby
        [2]
        ```
        
        - 例えばカフェで「全メニューの中から、注文したことがないものを取得」する問題を考えてみましょう。全メニューの配列から、注文したことがあるものの針列を引き算すると、まだ注文していないものの配列を得ることができます。
        
        ```ruby
        menu = ["カフェラテ", "モカ", "コーヒー", "エスプレッソ"] # 全メニュー
        ordered = ["エスプレッソ", "カフェラテ"] # 注文したことがあるもの
        p not_ordered = menu - ordered # 注文したことがないもの
        ```
        
        ```ruby
        ["モカ", "コーヒー"]
        ```
        
    - 📍まとめ
        
        ```ruby
        配列.unshift(追加するオブジェクト) # 配列の先頭へ追加
        配列.push(追加するオブジェクト) # 配列の末尾へ追加
        配列.shift # 配列の先頭から削除
        配列.pop # 配列の末尾から削除
        配列 + 配列 # 2つの配列の要素をつなげた配列を作る
        配列 - 配列 # 後ろの配列の要素を除いた配列を作る
        ```
        
        - unshiftメソッドは、配列の先頭へ追加する。
        - pushメソッドは、配列の末尾へ追加する。
        - shiftメソッドは、配列の先頭から削除する。
        - popメソッドは、配列の末尾から削除する。
        - 配列の足し算は、繋がった配列を作る。
        - 配列の引き算は、もとの配列から引く配列の要素を取り除いた配列を作る。
- 4-4 配列を繰り返し処理する
    
    ここでは、新しい技である「配列の全要素で繰り返し」を説明します。メニュー[”コーヒー", “カフェラテ", “モカ"]の全商品を表示するなど、配列の全ての要素に対して繰り返し処理するのはとても便利で有用な技です。これを使えば書けるプログラムの種類がどーんと広がります。
    
    - 配列を繰り返し処理する
        - 配列オブジェクト[”コーヒー”, “カフェラテ"]の全要素を表示するプログラムを書いてみます。
        
        ```ruby
        drinks = ["コーヒー", "カフェラテ"]
        drinks.esch do |drink| # ①
        	puts drink
        end
        ```
        
        ```ruby
        コーヒー
        カフェラテ
        ```
        
        - `each`メソッドは、配列の前要素を繰り返し処理するメソッドです。eachに続いて、`do |drink|`、そして`繰り返したい処理`と`end`を書きます。doとendは**ブロック**と呼ばれる部品です。繰り返し実行したい処理をブロックとして、**doの次の行からendの前の行までにインデントを一段下げて書きます**。
        - ①の|drink|、このdrinkは変数です。記号`|`(パイプと呼びます)で挟んで書きます。変数なので名前は自由に付けられます。この変数は、eachとの組み合わせで特別な働きをします。**eachメソッドの前に書かれた配列の各要素が、この変数drinkへ繰り返し代入されて実行されます**。
        - もしも、eachを使わずに書くと以下のようになるでしょう。
        
        ```ruby
        drinks = ["コーヒー", "カフェラテ"]
        puts drinks[0]
        puts drinks[1]
        ```
        
        ```ruby
        コーヒー
        カフェラテ
        ```
        
        - eachメソッドを使うと、配列の要素が増減して幾つになっても、繰り返し処理のプログラムを書き換えなくて良いというメリットがあります。
        
        ```ruby
        drinks = ["コーヒー", "カフェラテ", "モカ"] # 配列の要素を増やした
        drinks.each do |drink| # 繰り返し処理のプログラムは前と同じ
        	puts drink
        end
        ```
        
        ```ruby
        コーヒー
        カフェラテ
        モカ
        ```
        
    - 繰り返しを途中で終わらせる - `break`
        - breakを使うと繰り返し処理を途中で終わらせることができます。
        
        ```ruby
        [1, 2, 3].each do |x| # ①配列の書く要素を順番に変数xに代入
        	break if x == 2 # ②xの値が2の時に繰り返しを終わらせる
        	puts x # ③変数xの値を表示する
        end
        ```
        
        ```ruby
        1
        ```
        
        ```ruby
        配列オブジェクト[1, 2, 3]に対してeachメソッドを呼び出しています。
        ①で繰り返しの1回目はxに代入されてブロックが実行されます。
        xの値が1なので②のif x == 2は条件を満たさず、breakは実行されません。
        ③のputs xを実行して2回目の繰り返し処理へ進みます。
        
        繰り返しの2回目は①でxに2が代入されてブロックが実行されます。
        xの値が2なので、今度は②のif x == 2は条件を満たし、breakが実行されます。
        breakはeachメソッドのdo endブロックで繰り返されている繰り返し処理をそこで終わりにして、
        endの次の行へ処理が進みます。
        そのため、このプログラムでは「x = 2のputs x」も「x = 3の3回目のループ」も実行されません。
        
        このように、breakは繰り返しのブロック中で途中で処理を終わりにしたい時に使います。
        ```
        
    - 繰り返しの次の回へ進む - `next`
        - nextを使うと、繰り返し処理のその回をそこで終わりにして、次の回へ進みます。
        
        ```ruby
        [1, 2, 3].each do |x|
        	next if x == 2
        	puts x
        end
        ```
        
        ```ruby
        1
        3
        ```
        
        ```ruby
        1回目の繰り返し処理ではifの条件が満たされずにnextは実行されないため、puts xにより1が表示されます。
        2回目はxに2が代入されて処理が進み、
        nextの行でifの条件x == 2が満たされるため、nextが実行されます。
        nextは繰り返されているブロックの今回の処理をそこで終わりにして、次回の繰り返し処理を開始します。
        つまり、2回目の処理ではputs xは行われません。
        
        3回目の処理は1回目と同様で、ifの条件が満たされずにnextは実行されないため、puts xにより3が表示されます。
        このように、nextは繰り返しの特定の回は途中までしか実行せずに、
        繰り返し処理は続ける場合に使います。
        ```
        
    - COLUMN `each`につづくブロックで使う変数の名前
        - 配列を代入する変数は**複数形**、繰り返しの中の変数は**単数形**を使うと分かりやすく書くことができます。
    - 範囲を指定して繰り返す
        - 「3から5までの数を1ずつ増やして繰り返したい」ときには以下のように書くことができます。3..5は「3から5まで」の範囲を表すオブジェクトで、Rangeオブジェクトと呼ばれます。Rangeオブジェクトにeachメソッドを呼び出すと、ブロック中の変数にその範囲の数値を代入して繰り返します。ここでは、ブロック中の変数xに3、4、5をそれぞれ代入して、合計3回の繰り返し処理を実行します。
        
        ```ruby
        (3..5).each do |x|
        	puts x
        end
        ```
        
        ```ruby
        3
        4
        5
        ```
        
    - 📍まとめ
        
        ```ruby
        配列.each do |変数|
        	繰り返し実行する処理
        end
        ```
        
        - eachメソッドとブロックを使うと配列の全要素を繰り返し処理できる。
        - 各要素が変数に代入されて、繰り返し処理が実行される。
        - 配列の要素数が幾つでも、同じプログラムで全要素を繰り返し処理できる。</details>

**<details><summary>CHAPTER 5 便利な道具を使う</summary>**
ここまでの知識と、この章で紹介する配列の便利なメソッドを使うと、ぐっと書けるプログラムの種類が増えてきます。この章では配列の便利なメソッドを紹介しながら、様々なプログラムを書いていきます。また、リファレンスマニュアルの調べ方を説明します。この章で、自分で調べながらたくさんのプログラムが書けるようになる力を身に付けましょう。
- 5-1 配列の便利なメソッドを使う
    
    配列にはさまざまな便利なメソッドが用意されています。それらのメソッドを利用して様々なプログラムを書いていきましょう。
    
    - 配列の要素数を得る - `size`メソッド
        - 配列の要素数を得る時は`size`メソッドを使います。**sizeメソッドは配列の要素数を返すメソッドです**。
        
        ```ruby
        puts [2, 4, 6].size #=> 3
        ```
        
        ```ruby
        3
        ```
        
        - sizeメソッドは呼び出されると、配列の要素数を返します。メソッドの実行結果として返ってくる値のことを、「**戻り値**」といいます。戻り値は、数字だけでなく色々なオブジェクトを返すことができます。尚、戻り値を使わない時には無視しても構いません。**例えばputsメソッドやpメソッドでは戻り値を使うことはあまりありません**。
    - 配列の全要素の合計を得る - `sum`メソッド
        - 配列の全要素の合計は`sum`メソッドで計算できます。
        
        ```ruby
        puts [1, 2, 3].sum
        ```
        
        ```ruby
        6
        ```
        
        - sumメソッドの戻り値は、配列の全要素を足した値です。ここでは1 + 2 + 3の結果である6が戻り値です。
        - 先程のsizeメソッドと組み合わせると平均値の計算ができます。平均値は「全要素の合計/要素数」で計算できるので、次のようになります。
        
        ```ruby
        a = [1, 2, 3]
        puts a.sum / a.size
        ```
        
        ```ruby
        2
        ```
        
        ```ruby
        puts a.sum / a.size
        ↓
        puts 6 / 3
        ↓
        puts 2
        ```
        
    - COLUMN 少数が出てくる計算
        
        ```ruby
        a = [1, 1, 3]
        puts a.sum / a.size
        ```
        
        ```ruby
        1
        ```
        
        ```ruby
        5 ÷ 3の計算なので1.67くらいになりますが、小数点以下の計算はしてくれませんでした。
        これはsumメソッドもsezeメソッドも整数オブジェクトを返すので、整数オブジェクト同士の除算になり、
        答えも整数オブジェクトになるためです。
        
        小数点以下を計算したい場合は、どちらか(または両方)の数をto_fメソッドで少数オブジェクトに変換します。
        ```
        
        ```ruby
        a = [1, 1, 3]
        puts a.sum.to_f / a.size
        ```
        
        ```ruby
        1.6666666666666667
        ```
        
        ```ruby
        a.sum.to_fはsumメソッドとto_fメソッドをつなげて書いています。
        この場合は、メソッドが前の方から呼び出されていきます。
        まず、a.sumが実行されて、戻り値である5で置き換えられます。
        続いて5.to_fが実行されて、戻り値である5.0が得られます。
        続けて割り算5.0 / 3実行され、その結果をputsメソッドで表示しています。
        ```
        
        - ここで書いたa.sum.to_fのように、メソッドをつなげて書く方法を**メソッドチェイン**と呼びます。この書き方を使うと短く、読みやすく書くことができるのでよく使われる書き方です。
    - 📍まとめ
        - sizeメソッドを使うと配列の要素数を得られる。
        - 「メソッドが返した値」のことを「戻り値」という。
        - メソッド呼び出しがされた、戻り値で置き換えてプログラムを読み進める。
        - sumメソッドを使うと配列の全要素を足し合わせた数を得られる。
- 5-2 メソッドの機能を調べる
    
    「配列でこんなことはできないだろうか」「このメソッドの意味はなんだろう？」といった疑問が浮かんだ時は、リファレンスマニュアルを調べてみましょう。リファレンスマニュアルは、Rubyについての調べ物ができる辞書のようなWebページです。
    
    - リファレンスマニュアルとは
        - Rubyについての調べ物ができる辞書のようなWebページです。
        - [**Rubyリファレンスマニュアル**](https://docs.ruby-lang.org/ja/)
    - メソッドの名前から機能を調べる - `uniq`メソッド
        
        ```ruby
        uniq -> Array # 戻り値のオブジェクト種類はArray(配列)
        uniq! - > self | nil # 戻り値のオブジェクト種類は自分自身 または nil
        uniq {|item| ... } -> Array # ブロック({から}まで)を渡すこともできる
        uniq! {|item| ... } -> self | nil
        ```
        
        ```ruby
        uniq は配列から重複した要素を取り除いた新しい配列を返します。
        ```
        
        ```ruby
        uniq! は削除を破壊的に行い、削除が行われた場合は self を、そうでなければ nil を返します。
        ```
        
        ```ruby
        取り除かれた要素の部分は前に詰められます。要素の重複判定は、Object#eql? により行われます。
        # 「要素の重複判定は、Object#eql?により行われます」は、簡単な理解では==を使って値が同じかどうかを判定していると考えてもらって大丈夫です。
        ```
        
        ```ruby
        p [1, 1, 1].uniq       # => [1]
        p [1, 4, 1].uniq       # => [1, 4]
        p [1, 3, 2, 2, 3].uni1 # => [1, 3, 2]
        ```
        
    - 末尾に!がつくメソッド
        - uniqは、重複している要素を取り除くメソッドです。自分自身の要素は変わらずに、重複する要素を取り除いた新しい配列を返します。
        
        ```ruby
        array1 = [1, 1, 2]
        array2 = array1.uniq
        p array1 #=> [1, 1, 2] array1地震は変わっていない
        p array2 #=> [1, 2]
        ```
        
        - uniq!も重複している要素を取り除くメソッドです。uniqとの違いは、自分自身(array1)の要素が変わることです。
        
        ```ruby
        array1 = [1, 1, 2]
        array2 = array1.uniq!
        p array1 #=> [1, 2] array1自身が変わっている
        p aaray2 #=> [1, 2]
        ```
        
        - uniqとuniq!の違いは、自分自身の配列オブジェクトを変更するかどうかです。uniq!メソッドのような自分自身の配列オブジェクトを変更することを「破壊的変更」と言います。
        - 新しいオブジェクトが作られたか、破壊的に変更されたかはobject_idというメソッドを使うと分かります。object_idメソッドは、それぞれのオブジェクトに割り当てられる識別番号(オブジェクトID)を返すメソッドです。オブジェクトIDはオブジェクトごとに異なります。
        
        ```ruby
        array1 = [1, 1, 2]
        array2 = array1.uniq
        p array1.object_id #=> 70177089914920
        p array2.object_id #=> 70177089914680 array1とarray2のオブジェクトIDが違う
        ```
        
        ```ruby
        array1 = [1, 1, 2]
        array2 = array1.uniq!
        p array1.object_id #=> 70177089914920
        p array2.object_id #=> 70177089914920 array1とarray2のオブジェクトIDが同じ
        ```
        
        - uniqメソッドは自分自身の配列オブジェクトを変更せずに、新しい配列オブジェクトを作ります。そのため、新しい配列オブジェクトを代入したarray2のオブジェクトIDは、元のオブジェクトIDとは異なっています。オブジェクトIDが違うということは、オブジェクトが2つあるということです。
        - 一方のuniq!メソッドは新し配列オブジェクトを作りません。そのため、array1とarray2は同じオブジェクトIDになります。オブジェクトは1つで、その1つのオブジェクトにarray1とarray2の2つの名札を付けている状態です。
        - 元の配列を残しておきたいかどうかで、uniqとuniq!を使い分けると良いでしょう。
        - !が付くと対象のオブジェクトを破壊的に変更するものが多いです。
    - ブロックを渡せるメソッド
        - メソッドにはブロックを渡せるものがあります。eachもその1つです。uniqメソッドにもブロックを渡すこともできる旨がリファレンスマニュアルに書かれています。
        
        ```ruby
        ブロックが与えられた場合、ブロックが返した値が重複した要素を取り除いた配列を返します。
        次のプログラムは、uniqへブロックを渡さない時の例と、渡した時の例です。
        
        p [1, 3, 2, "2", "3"].uniq                # => [1, 3, 2, "2", "3"]
        p [1, 3, 2, "2", "3"].uniq { |n| n.to_s } # => [1, 3, 2]
        
        { |n| n.to_s }がブロックです。文中の「ブロックが与えられた場合」とは、uniq { |n| n.to_s }
        のようにメソッドの後ろにブロックを書いている場合に相当します。
        これを「ブロック渡す」とも表現します。メソッドへブロックを渡しているイメージです。
        
        ブロックを渡した時の動作は、eachメソッドの時と似ています。
        |n|のnが変数で、配列の要素が1つずつ代入されます。
        ブロックでは、n.to_sが実行され、その結果を使ってuniqが実行されます。
        to_sは文字列へ変換するメソッドで、1は"1"へ変換します。
        つまり、ブロックの処理によって「3と"3"」および「2と"2"」は重複と判定され、
        取り除かれることになります。
        ```
        
        - ブロックはRubyの数ある仕組みの中でも、とてもよく使われるものです。
    - 📍まとめ
        - リファレンスマニュアルはRubyについての調べ物ができる辞書のような情報。
        - uniqメソッドは重複している要素を取り除く。
        - 末尾に！が付く、付かないの2つのメソッドが用意されていることがある。
        - 末尾に！が付かないメソッドは、操作後の新しい配列オブジェクトを作って返すものが多い。
        - 末尾に！が付くメソッドは、オブジェクトを破壊的に変更するものが多い。
    - [**COLUMN るりまサーチ**](https://docs.ruby-lang.org/ja/search/)
        - 先程のuniqメソッドのように、メソッド名が分かっていて、その働きを調べたい時は「るりまサーチ」と使う方法もあります。リファレンスマニュアルの全ページから検索することができます。
- 5-3 機能からメソッドを探す
    
    「配列の要素の中からランダムに1つ取得したい」ケースを考えてみます。どんなメソッドを使えばいいか、リファレンスマニュアルを使って調べてみましょう。
    
    - ランダムに要素を取得する - `sample`メソッド
        - sampleメソッドは配列からランダムに要素を取得します。
        
        ```ruby
        puts [1, 2, 3].sample
        ```
        
        ```ruby
        2 # 実行結果はランダムに1、2、3のいずれかを表示する。
        ```
        
    - COLUMN ランダムに並び替える`shuffle`メソッド
        - shuffleメソッドは配列の要素をランダムに並び替えるメソッドです。
        
        ```ruby
        p [1, 2, 3].shuffle #=> [1, 3, 2]
        ```
        
    - 📍まとめ
        - sampleメソッドは配列からランダムに要素を取得する。
        - shuffleメソッドは配列をランダムに並び替える。
- 5-4 配列の要素を順に並び換える
    
    配列はオブジェクトを順番に並べて扱います。順番を並び替えることで、小さい順に並べたり、abc順に並べることもできます。
    
    - 配列の要素を順に並び替える - `sort`メソッド
        - sortメソッドは、要素を順に並べるメソッドです。配列の要素が数値の時は、小さい順に並び替えられます。
        
        ```ruby
        p [4, 2, 8].sort
        ```
        
        ```ruby
        [2, 4, 8]
        ```
        
        - 配列の要素が文字列の時は、abc順に並び替えられます。先頭の文字で比較し、同じであれば2文字目、と比較します。大文字が混じると「大文字が咲き、小文字が後」になります。
        
        ```ruby
        p ["hitomi", "achi", "tama"].sort
        p ["aya", "achi", "tama"].sort
        p ["aya", "achi", "Tama"].sort
        ```
        
        ```ruby
        ["achi", "hitomi", "tama"]
        ["achi", "aya", "tama"]
        ["Tama", "achi", "aya"]
        ```
        
    - 配列の要素を逆順にする
        - 逆順にするには`reverse`メソッドを使います。reverseメソッドは、**配列の並び順を逆順にするメソッドです**。
        
        ```ruby
        p [4, 2, 8].sort # sortで小さい順に
        p [4, 2, 8].sort.reverse # sortで小さい順にした配列を、さらにreverseで逆順にする
        ```
        
        ```ruby
        [2, 4, 8]
        [8, 4, 2]
        ```
        
        ```ruby
        ↑ここではメソッドチェインを使って繋げて書きました。
        メソッドが前の方から呼び出されていきます。
        先ず、[4, 2, 8].sortが実行されて、戻り値である[2, 4, 8]に置き換えます。
        続いて、[2, 4, 8].reverseが実行されて、戻り値である[8, 4, 2]が得られます。
        最後にp [8, 4, 2]が実行されて、[8, 4, 2]が表示されます。
        ```
        
    - COLUMN 文字列を逆順にする
        - `reverse`メソッドは配列のほか、文字列にも用意されています。
        
        ```ruby
        p "abc".reverse #=> "cba"
        p "とくれせんたぼーび".reverse #=> "びーぼたんせれくと"
        ```
        
    - 📍まとめ
        - sortメソッドを使うと配列の要素が順に並び替えられる。
        - reverseメソッドを使うと配列の要素の並びが逆順になる。
        - reverseメソッドを使うと文字列の並びが逆順になる。
- 5-5 配列と文字列を変換する
    
    配列と文字列を組み合わせて使うと、いろいろな問題を解決できます。配列中の文字列を繋ぎ合わせる`join`メソッドと、文字列を分割して配列にする`split`メソッドを説明します。
    
    - 配列中の文字列を連結する - `join`メソッド
        - joinメソッドは、配列中の文字列を連結するメソッドです。
        
        ```ruby
        puts ["カフェラテ"].join
        puts ["カフェラテ", "チーズケーキ"].join
        puts ["カフェラテ", "チーズケーキ", "バニラアイス"].join
        ```
        
        ```ruby
        カフェラテ
        カフェラテチーズケーキ
        カフェラテチーズケーキバニラアイス
        ```
        
        - joinメソッドは配列の各要素を繋げるだけでなく、繋げる時に間へ入れる文字を指定できます。join(”と”)のように書くと、各要素の間に「と」を入れて連結します。
        
        ```ruby
        puts ["カフェラテ"].join("と")
        puts ["カフェラテ", "チーズケーキ"].join("と")
        puts ["カフェラテ", "チーズケーキ", "バニラアイス"].join("と")
        ```
        
        ```ruby
        カフェラテ
        カフェラテとチーズケーキ
        カフェラテとチーズケーキとバニラアイス
        ```
        
    - COLUMN メソッドと引数
        - 今回のプログラムjoin(”と")では、繋げる時に間へ入れる文字である"と"をjoinメソッドへ渡しています。このようなメソッドへ渡すオブジェクトのことを、「引数(ひきすう)」と呼びます。リファレンスマニュアルを読んでいると、引数という言葉が出てくることもあるので、その時は、「メソッドへ渡すオブジェクト」と置き換えて読んでみてください。
    - 文字列を分割して配列にする - `split`メソッド
        - splitメソッドは文字列を区切り文字で分割して配列にするメソッドです。
        
        ```ruby
        p "カフェラテ チーズケーキ バニラアイス".split
        ```
        
        ```ruby
        ["カフェラテ", "チーズケーキ", "バニラアイス"]
        ```
        
        - splitメソッドに区切り文字を渡すことで、スペース以外の区切り文字にも対応できます。
        
        ```ruby
        p "カフェラテとチーズケーキとバニラアイス".split("と")
        ```
        
        ```ruby
        ["カフェラテ", "チーズケーキ", "バニラアイス"]
        ```
        
        - joinメソッドは、配列の要素を連結して文字列に変換。splitメソッドは、文字列を区切って配列に変換。と、逆の操作になっています。
    - 📍まとめ
        - joinメソッドを使うと、配列の全要素を繋げた文字列が作られる。
        - joinメソッドへ文字列を渡すと、要素間に挟んで繋げた文字列を作られる。
        - splitメソッドを使うと、文字列をスペースで区切って要素とした配列が作られる。
        - splitメソッドへ文字列を渡すと、区切り文字として使われる。
- 5-6 配列の各要素を変換する
    
    配列にまとめている各要素について、それぞれ同じ処理を行いたいことがあります。全要素をそれぞれ2倍したい、全要素を小文字にしたい、といったケースです。ここではmapメソッドを使って全要素への変換処理を書いてみましょう。
    
    - 配列の各要素を変換した配列を作る - `map`メソッド
        - mapメソッドは配列の各要素へ処理を行い、変換してできた要素を持った、新しい配列を作るメソッドです。
        
        ```ruby
        result = [1, 2, 3].map do |x| # xに1 2 3 が順に代入される
        	x * 2 # 変換処理
        end
        p result
        ```
        
        ```ruby
        [2, 4, 6]
        ```
        
        ```ruby
        ↑mapメソッドへ変換処理をブロックで渡します。ここでは配列の各要素1、2、3に対して、
        ブロックの処理x * 2をそれぞれ実行します。
        変数xに1、2、3が順に代入され、結果の2、4、6を要素として持つ配列を作って変数resultへ代入します。
        mapメソッドが返す配列は、元の配列と要素の数は変わりません。
        ```
        
        - mapメソッドは、要素を他の種類のオブジェクトへ変換する時にも便利に使えます。
        
        ```ruby
        result = [100, 200, 300].map do |x| # xに100 200 300が順に代入される
        	"#{x}円"
        end
        p result
        ```
        
        ```ruby
        ["100円", "200円", "300円"]
        ```
        
        ```ruby
        mapメソッドへ渡したブロックは、各要素が代入される変数xを使って、文字列"#{x}円"へと変換します。
        ```
        
    - 特定のブロックには短い書き方がある
        - 次のプログラムは、配列にmapメソッドを呼び出し、各要素の文字列をreverseメソッドで逆順にするプログラムです。
        
        ```ruby
        result = ["abc", "123"].map do |text|
        	text.reverse
        end
        p result
        ```
        
        ```ruby
        ["cba", "321"]
        ```
        
        - ↑ブロックはdo~endの代わりに{}を使って1行で書けます
        
        ```ruby
        
        result = ["abc", "123"].map{|text| text.reverse}
        p result
        ```
        
        ```ruby
        ["cba", "321"]
        ```
        
        - #↑さらにこのmapメソッドのように、各要素に対してあるメソッドを呼び出すだけのブロックは特別に短く書く方法が用意されています。
        
        ```ruby
        
        result = ["abc", "123"].map(&:reverse)
        p result
        ```
        
        ```ruby
        ["cba", "321"]
        ```
        
        - ブロックで呼び出したいメソッド(ここではreverse)の先頭に:を付けてシンボルにします。さらに先頭に&を付けて渡します。
    - 📍まとめ
        
        ```ruby
        配列.map do |変数|
        	変換処理
        end
        ```
        
        - mapメソッドは、配列の全要素にブロック中の処理で変換を行なった、新しい配列を作る。</details>

**<details><summary>CHAPTER 6 組みで扱う - ハッシュ</summary>**
カフェのメニューには商品名と値段が書かれています。このような「名前と値のセット」を取り扱うために、Rubyでは「ハッシュ」という道具が用意されています。ハッシュは辞書のように、データを整理して扱うことができるとても便利な道具です。
- 6-1 オブジェクトを組で扱う
    
    商品名と値段が書かれたカフェのメニューのような「名前と値のセット」を取り扱うために、Rubyでは「ハッシュ(Hash)」という道具が用意されています。ハッシュとはどのようなものか、どのように使うことができるのか、見ていきましょう。
    
    - ハッシュ(Hash)とは
        - ハッシュは複数のオブジェクトをまとめることができる入れ物です。ハッシュは「キー」と「値」のセットで複数のデータを扱うことができます。構造が似ている辞書に例えて説明すると、辞書の「見出し語」がハッシュでは「キー」、辞書の「書かれた意味」がハッシュでは「値」になります。
        - 例えば、カフェでのメニューの商品名と値段を表現するケースを考えます。コーヒーが300円、カフェラテが400円というメニューを、ハッシュを使うと以下のように書けます。
        
        ```ruby
        {:coffee => 300, :caffe_latte => 400}
        ```
        
        - ↑この例では:coffeeキーに対応する値が300、:caffe_latteキーに対応する値が400です。ハッシュのキーと値にはどんな種類のオブジェクトも書くことができます。
        - 配列と同じように、ハッシュもオブジェクトです。配列のクラス名はArryaでしたが、ハッシュのクラス名は`Hash`です。ハッシュのことを、**ハッシュオブジェクト**、**Hashオブジェクト**、**ハッシュ**と呼びます。
        
        ```ruby
        p( {:coffee => 300, :caffe_latte => 400} )
        ```
        
        ```ruby
        {:coffee=>300, :caffe_latte=>400}
        ```
        
        - このプログラムでは、pメソッドに続く括弧()を省略せずに書いています。このハッシュをpメソッドに渡す時に括弧を省略すると、文法の解釈が曖昧になってエラーとなるためです。
        - この`:coffee`と`:caffe_latte`はシンボルという新しい種類のオブジェクトです。
    - シンボル(Symbol)とは
        - シンボルは文字列と似ているオブジェクトです。文字列は”coffee”のようにダブルクォーテーションで囲みますが、シンボルはコロン記号(`:`)から始めます。
        - シンボルも文字列や整数と同じようにオブジェクトの種類の1つです。シンボルのクラス名は**Symbol**です。シンボルはハッシュのキーでラベルのように使われます。
        - シンボルは文字列と相互に変換することができます。文字列からシンボルへは**to_sym**メソッドを、シンボルから文字列へは**to_s**メソッドを使います。
        
        ```ruby
        p "coffee".to_sym #=> :coffee
        p :coffee.to_s #=> "coffee"
        ```
        
    - ハッシュには2つの書き方がある
        - ハッシュには別の書き方が用意されています。同じ意味のハッシュを、2種類の書き方で書くと次のようになります。
        
        ```ruby
        {:coffee => 300, :caffe_latte => 400} # ①
        {coffee: 300, caffe_latte: 400} # ②
        ```
        
        - ①はここまでで紹介した書き方で、②は新しい書き方です。②の書き方では、:の前にキーを書き、後ろに値を書きます。ハッシュの書き方の主流です。
        - 尚、②の書き方はハッシュのキーにシンボルを指定した時のみ使えます。ハッシュのキーに文字列などシンボル以外のオブジェクトを使う時は、①のようにハッシュロケット`=>`を使って書きます。
        
        ```ruby
        {"コーヒー" => 300, "カフェラテ" => 400}
        ```
        
    - 変数に代入してハッシュに名前を付ける
        - 変数への代入は、他のオブジェクトの時と同じく、ハッシュオブジェクトに名札をつけるイメージです。
        
        ```ruby
        menu = {:coffee => 300, :caffe_latte => 400} # ①変数menuへ代入
        p menu # ②変数menuに代入されているハッシュオブジェクトを表示
        ```
        
        ```ruby
        {:coffee=>300, :caffe_latte=>400}
        ```
        
        - ①の行でハッシュオブジェクトを作り、変数menuに代入しています。続けて②の行で、変数menuに代入されているハッシュオブジェクトを表示しています。
    - ハッシュから値を取得する
        
        ```ruby
        menu = {coffee: 300, caffe_latte: 400}
        p menu[:coffee] # ①キーはcoffeeではなくて:coffeeと書くことに注意
        ```
        
        ```ruby
        300
        ```
        
        - キーはシンボルなので、先頭にコロン「:」が付きます。
        - 値の取得は**ハッシュ[キー]**という書き方をします。今回はハッシュが代入された変数menuを使って`menu[:coffee]`と書いています。
    - COLUMN こんなハッシュも書くことができる
        - ハッシュのキーの部分にはシンボルを使うことが多いのに対して、値の部分にはさまざまなオブジェクトを置きます。文字列や整数だけでなく、配列や別のハッシュを置くこともできます。
        
        ```ruby
        {title: "Ruby Book", members: ["yano", "beco"]}
        ```
        
        - また、からのハッシュは`{}`と書きます。
    - 📍まとめ
        - ハッシュの書き方、キーがシンボルの時の書き方
        
        ```ruby
        {キー: 値, キー: 値}
        ```
        
        - キーがシンボル以外でも使える書き方
        
        ```ruby
        {キー => 値, キー => 値}
        ```
        
        - ハッシュのキーから値を取得
        
        ```ruby
        ハッシュ[キー]
        ```
        
        - ハッシュ(Hash)オブジェクトは複数のオブジェクトをキーと値の組みでまとめて扱うもの。
        - ハッシュは`{`で始まり、`}`で終わり、カンマ区切りでキーと値の組みを複数書くことができる。
        - キーにはシンボルが使われることが多い。
        - `{}`は空のハッシュ。
        - ハッシュはキーから値を取得できる。
- 6-2 キーとアタイの組みを追加・削除する
    
    作ったハッシュに後から要素を追加したり、削除したりしてみましょう。
    
    - ハッシュへキーと値の組を追加する
        
        ```ruby
        menu = {coffee: 300, caffe_latte:400}
        menu[:mocha] = 400 # キー :mocha, 値 400 の組を追加
        p menu
        ```
        
        ```ruby
        {:coffee=>300, :caffe_latte=>400, :mocha=>400}
        ```
        
        - ハッシュmenuに対して`menu[:mocha] = 400`のようにキーと値の組を書きます。`menu[:mocha]`に対する代入と考えると覚えやすいでしょう。
        - **追加したキーと値の組は末尾に追加されます**。
    - ハッシュは同じキーを複数持てない
        
        ```ruby
        menu = {coffee: 300, caffe_latte: 400}
        menu[:coffee] = 350 # 既にあるキー :coffee を追加
        p menu
        ```
        
        ```ruby
        {:coffee=>350, :caffe_latte=>400} # キー:coffeeの値が350で上書きされた
        ```
        
        - **既にあるキーと値の組を追加すると、後から追加したもので上書きされます**。**ハッシュは同じキーを複数持つことはできません**。言い換えると、キーに対する値を上書きして変更する時には、代入と同様の方法で行うことができます。
    - 存在しないキーを指定した時
        
        ```ruby
        menu = {coffee: 300, caffe_latte: 400}
        p menu[:tea]
        ```
        
        ```ruby
        nil
        ```
        
        - ハッシュから存在しないキーを指定して値を取得しようとすると、nilが得られます。
        - 存在しないキーを指定した時の値は、`default=メソッド`で設定することもできます。次のように書くと、存在しないキーで値を取得しようとした時、nilの代わりに`default=メソッド`で指定した`0`が得られます。
        
        ```ruby
        menu = {coffee: 300, caffe_latte: 400}
        menu.default = 0 # キーがない時の値を設定
        p menu[:tea] # nilではなくdefaultに指定した0になる
        ```
        
        ```ruby
        0
        ```
        
    - 2つのハッシュを1つにまとめる
        - 2つのハッシュを1つにまとめる時は`merge`メソッドを使います。mergeメソッドは元のハッシュと、指定したハッシュを1つにまとめて新しいハッシュを作るメソッドです。
        
        ```ruby
        menu = {coffee: 300, caffe_latte: 400}
        tea_menu = [tea: 300, tea_latte: 400}
        menu = coffee_menu.merge(tea_menu)
        p menu[:tea]
        ```
        
        ```ruby
        {:coffee=>300, :caffe_latte=>400, :tea=>300, :tea_latte=>400}
        ```
        
        - ハッシュ`coffee_menu`とハッシュ`tea_menu`をまとめた新しいハッシュmenuを作っています。
    - ハッシュからキーと値の組を削除する
        - ハッシュからキーと値の組を削除する時はdeleteメソッドを使います。`ハッシュ.delete(キー)`  と書くと、指定したキーと値の組を削除します。値を指定する必要はありません。
        
        ```ruby
        menu = {coffee: 300, caffe_latte: 400}
        menu.delete(:caffe_latte)
        p menu[:tea]
        ```
        
        ```ruby
        {:coffee=>300}
        ```
        
        - ハッシュmenuからdeleteメソッドを使ってキー:cafe_latteとそれと組である値400を削除しています。ハッシュmenuにはキー:coffeeと値300の組だけが残っています。
    - 📍まとめ
        - ハッシュへキーと値の組を追加

        ```ruby
        ハッシュ[キー] = 値
        ```

        - ハッシュへのキーと値の追加はハッシュ[キー] = 値
        - ハッシュは同じキーを複数持てない。
        - ハッシュから存在しないキーを取得すると、nilを得る。
        - ハッシュからの削除はハッシュ.delete(キー)
- 6-3 ハッシュの要素を繰り返し処理する
    
    ハッシュも複数のオブジェクトをまとめているので、配列と同じように全要素で繰り返し処理をするeachメソッドが用意されています。メソッドの名前も配列と一緒ですね。
    
    - ハッシュを繰り返し処理する
        - カフェでのメニューが書かれたハッシュを一覧表示してみましょう。
        
        ```ruby
        menu = {"コーヒー" => 300, "カフェラテ" => 400}
        menu.each do |key, value| # ハッシュのeachメソッドでは、ブロックの変数は2つ
        	puts "#{key}は#{value}円です"
        end
        ```
        
        ```ruby
        コーヒーは300円です
        カフェラテは400円です
        ```
        
        - `||`に挟まれた、ブロックの中の変数のところが`|key, value|`と変数2つになっています。配列の時は1つだけでした。**ハッシュはキーと値の組なので、繰り返し処理のブロック中で両方が使えるようになっています**。**1つ目の変数にキーが、2つ目の変数に値が代入されて繰り返しが実行されます**。**変数の名前は、自由に名付けることができます**。
        - ハッシュの繰り返し処理
        
        ```ruby
        ハッシュ.each do |キーの変数, 値の変数|
        	繰り返し実行する処理
        end
        ```
        
        - 「キーだけを繰り返し処理したい」ときには、eachメソッドを使って変数valueを使わなくても構いません。または、`each_key`メソッドという、キーだけで繰り返しを行うメソッドもあります。
        
        ```ruby
        menu = {"コーヒー" => 300, "カフェラテ" => 400}
        menu.each_key do |key| # each_key メソッドでは、ブロックの変数は1つ
        	puts key
        end
        ```
        
        ```ruby
        コーヒー
        カフェラテ
        ```
        
        - 同時に値だけを繰り返しするeach_valueメソッドもあります。
    - 📍まとめ
        - eachメソッドとブロックを使うとハッシュの全要素を繰り返し処理できる。
        - キーと値がそれぞれ変数に代入されて、繰り返し処理が実行される。</details>

**<details><summary>CHAPTER 7 小さく分割する - メソッド</summary>**
プログラムが大きくなってきたときに、意味のあるまとまりで分割することで、書きやすく、また読みやすいプログラムにすることができます。また、同じ処理は1箇所にまとめて書くことで共同利用することもできます。この章では「メソッド」を使ってプログラムを分化して書く方法について説明していきます。
- 7-1 メソッドを作って呼び出す
    
    メソッドは「処理のかたまりを部品化して名前を付けたもの」です。これまでに出てきたメソッドを改めておさらいして、メソッドを自分で作って呼び出してみましょう。
    
    - メソッドとは
        - メソッドは名前をつけた「処理の部品」です。putsやpは「画面に表示する処理」の部品、sumは「合計値を計算する処理」の部品、といった具合です。名前をつけて部品にしておくことにはメリットがあります。ある処理を書くときに、1から全てのプログラムを書くのではなく、既に用意されている名付けられた処理の部品、つまりメソッドを使うことで、プログラムを簡単に書くことができます。
        - また、sumメソッドを使えば、配列の全要素の合計を簡単に計算できるだけでなく、プログラムもぐっと読みやすくなります。
        
        ```ruby
        a = [1, 2, 3]
        puts a.sum #=> 6
        ```
        
        ```ruby
        a = [1, 2, 3]
        sum = 0
        a.each do |x|
        	sum += x
        end
        puts sum #=> 6
        ```
        
        - sumメソッドを使った方はとても短くかけています。読みやすいプログラムになっています。
    - メソッドを定義する
        - メソッドを作ることを「メソッドを定義する」と言います。
        
        ```ruby
        def area # area(面積)という名前のメソッドを定義 ここから
        	puts 2 * 2 # メソッドの処理(メソッド定義だけでは実行されない)
        end # areaメソッド定義 ここまで
        ```
        
        ```ruby
        						# 何も表示されません
        ```
        
        - 実行しても何も表示されませんが、意図通りです。メソッド中の処理`puts 2 * 2`はメソッド定義の時には実行されません。あとからメソッドが呼び出された時に実行されます。
        - メソッドを定義するには、`def`に続いてメソッド名を書きます。defは後に続く名前のメソッドを定義します。ここでは、area(面積)と名付けました。defの次の行からメソッドでの処理を書き、`end`を書いて終わります。ブロックではないので、`do`は不要です。メソッド中はインデントを下げて書きます。メソッドの中では、辺の長さ2の正方形の面積を計算して画面に表示する処理をしています。
        - メソッドの名前には英字、数字、_などを使うことができますが、数字から始めることはできません。**慣習では、英字は全て小文字で書き、2単語以上を繋げる時は_を間に入れます**。
    - メソッドを呼び出す
        - メソッドを実行することを「呼び出す」といいます。
        
        ```ruby
        def area
        	puts 2 * 2
        end
        
        area # 定義したareaメソッドを呼び出し
        ```
        
        ```ruby
        4
        ```
        
        - **定義したメソッドは、メソッド名を書くことで呼び出す(実行する)ことができます**。`area`と書くとメソッドが呼び出され、メソッド中の処理を実行し、2 * 2を計算して画面に表示します。
    - メソッドの戻り値とは
        
        ```ruby
        def area
        	2 * 2 # メソッドの最後の実行結果 4 が戻り値として呼び出し元へ返る
        end
        
        puts area # メソッド呼び出し area が戻り値である 4 で置き換わって puts 4 となる
        ```
        
        ```ruby
        4
        ```
        
        - メソッドは最後の実行結果が戻り値として呼び出し元へ返る仕組みです。戻り値は変数に代入することもできます。
        
        ```ruby
        def area
        	2 * 2 # 戻り値は 4
        end
        
        result = area # area が戻り値 4 で置き換わって result = 4 となる
        puts result
        ```
        
        - areaメソッドの戻り値4を、変数resultに代入しています。これで、結果を使ってさらに別の計算をしたり、画面ではなくファイルへ書き出したりするなど、画面に表示する以外のケースでもareaメソッドを利用できるようになって利用範囲が広がりました。
    - 📍まとめ
        - メソッド定義
        
        ```ruby
        def メソッド名
        	処理
        end
        ```
        
        - メソッド呼び出し
        
        ```ruby
        メソッド名
        ```
        
        - メソッドは「処理の部品」に名前を付けたもの。
        - メソッド定義(作成)はdefを使う。
        - メソッドは定義しただけでは中の処理は実行されない。
        - 定義したメソッドは呼び出すことで実行される。
        - メソッドはオブジェクトを呼び出し元に返す戻り値の仕組みがある。
        - メソッドで最後に実行した結果が戻り値になる。
- 7-2 メソッドへオブジェクトを渡す
    
    戻り値を使うことで、メソッドから呼び出し元へオブジェクトを返すことができました。逆に「引数」という機能を使うことで、呼び出し元からメソッドへオブジェクトを渡すことができます。
    
    - 引数を使ってオブジェクトを渡せるメソッドを定義する。
        - メソッドには引数というオブジェクトを渡す機能が用意されています。
        
        ```ruby
        def area(x) # ②引数の2をxへ代入
        	x * x # ③2 × 2を計算し、戻り値4を返す
        end
        
        puts area(2) # ①メソッド呼び出し(引数は2)
        ```
        
        ```ruby
        4
        ```
        
        - 呼び出し元では、①でメソッドを呼び出す時に、`area(2)`のようにメソッド名に続いて`()`ないに渡すオブジェクトを書きます。ここでは、2が引数としてメソッドへ渡されます。メソッド定義側では`def area(x)`のようにメソッド名に続いて`()`の中に変数を書きます。**この変数xも引数と呼びます**。②では、呼び出し元から渡されたオブジェクトが、この変数へ自動的に代入されます。ここでは変数xへ2が代入されます。**この変数はメソッドの中で使うことができます**。③では、変数xを使って**x * x**の面積の計算をしています。メソッドの最後の実行結果が戻り値として帰ります。ここで**x**には**2**が代入されているので、**2 * 2**の結果である**4**が戻り値となります。再び呼び出し元へ戻ります。戻り値の**4**で**area(2)**が置き換えられ、**puts 4**が実行されます。
        - 引数の仕組みをまとめると次のようになります。メソッド定義のdefでメソッド名の後ろに続けて(変数x)と書くと、メソッド呼び出しで引数としてオブジェクトを渡せるようになります。変数xには、呼び出し側から引数として渡ってきたオブジェクトが自動で代入されます。変数xは一般の変数と同じく、自由に名付けることができます。
        - メソッド呼び出しで引数を渡す時は、area(2)のようにメソッド名に続けて括弧書きで引数を書きます。areaメソッドが呼び出され、2が引数として渡されます。
        
        ```ruby
        def area(x) # 引数の3をxへ代入
        	x * x # 3 × 3を計算し、戻り値9を返す
        end
        
        puts area(3) # メソッド呼び出し(引数は3)
        ```
        
        ```ruby
        9
        ```
        
        - まとめると、引数はメソッドへオブジェクトを渡す機能です。そして、戻り値はメソッドから呼び出し元へオブジェクトを返す機能です。これらは対になる機能で、受け渡す方向が逆になります。
    - 2つ以上の引数を持つメソッドを定義する
        - 今度は長方形の面積を求めるメソッドを作ってみましょう。長方形の面積は2つの辺の長さを掛け合わせます。引数を2つ渡して辺の長さを計算するメソッドを書いてみましょう。
        
        ```ruby
        def area(x, y) # ②xに2、 yに3を代入
        	x * x # ③2 × 3の結果である戻り値6を返す
        end
        
        puts area(2, 3) # ①メソッド呼び出し(引数は2と3)
        ```
        
        ```ruby
        6
        ```
        
        - メソッド定義では、def area(x, y)と間まで区切って引数を2つ書いています。①でのメソッド呼び出しは、area(2, 3)とカンマで区切って渡す引数を書きます。②では、呼び出し元で書かれた順に、変数へ順に代入されます。xに2が、yに3が代入されます。③ではx * yを計算し、戻り値6を返します。
        - 引数は3つ以上にすることもできます。**原則として、引数の個数はメソッドの定義側と呼び出し元で同数にする必要があります**。
    - メソッドを途中で終わらせる - return
        - 注文のお礼を伝えてレシートを渡すメソッドを考えます。
        
        ```ruby
        def thanks_and_receipt
        	puts "ありがとうございました。"
        	puts "こちら、レシートになります。"
        end
        
        thanks_and_receipt
        ```
        
        - メソッド体調は如何でしょうか？thanks_and_receiptを呼び出すと、「ありがとうございました。」「こちら、レシートになります。」を表示します。
        - レシートを受け取らないお客さんへは、「こちら、レシートになります。」と省略して言わないように変更してみましょう。メソッドを途中で終わらせるには、`return`を書きます。
        
        ```ruby
        def thanks_and_receipt
        	puts "ありがとうございました。"
        	return # ここでメソッドが終わる
        	puts "こちら、レシートになります。" # この行は実行されない
        end
        
        thanks_and_receipt
        ```
        
        ```ruby
        ありがとうございました。
        ```
        
        - returnを書くとそこでメソッドの処理が終わり、呼び出し元へ戻ります。returnより後に書かれた行は実行されません。
        - returnを使ってメソッドを終わらせることができたので、次はreturnするかどうかを引数によって切り替えてみましょう。
        
        ```ruby
        def thanks_and_receipt(receipt)
        	puts "ありがとうございました。"
        	unless receipt # receiptがfalseのときに次の行を実行
        		return
        	end
        	puts "こちら、レシートになります。"
        end
        
        thanks_and_receipt(false)
        ```
        
        ```ruby
        ありがとうございました。
        ```
        
        - `thanks_and_receipt(false)`のように引数にfalseを渡すと、**変数receiptへfalseが代入されます**。変数receiptの値がfalseなのでunlessの条件が満たされません。**unlessは条件が満たされない時に処理を実行します**。そのため、returnが実行され、メソッドの処理が終わり呼び出し元へ戻ります。画面には「"ありがとうございました。"」だけが表示されます。
        - 一方で、`thanks_and_receipt(true)`のように引数にtrueを渡すと、unlessの条件が満たされます。その結果、returnが実行されずに「こちら、レシートになります。」まで表示されます。
        - returnには戻り値を指定する機能もあります。returnを使った時に戻り値を返したい場合は、returnに続いて戻り値を書きます。returnが実行されない時は、今まで通り最後に実行した処理が戻り値になります。
        
        ```ruby
        def thanks_and_receipt(receipt)
        	greeting = "ありがとうございました。"
        	unless receipt # receiptがfalseのときに次の行を実行
        		return greeting # returnを実行し、変数greetingに代入されたオブジェクトを戻り値にする
        	end
        	greeting + "こちら、レシートになります。" # "こちら、レシートになります。"を追加して戻り値にする
        end
        
        puts thanks_and_receipt(true) #=> ありがとうございました。こちら、レシートになります。
        puts thanks_and_receipt(false) #=> ありがとうございました。
        ```
        
        ```ruby
        ありがとうございました。こちら、レシートになります。
        ありがとうございました。
        ```
        
        - thanks_and_receiptメソッドを文字列を返すように変更しました。引数としてtrueを渡すと、メソッドの最後の実行結果greeting + “こちら、レシートになります。”が帰ります。
        - 引数としてfalseを渡すと、return greetingが実行されます。returnは後に続くオブジェクトを戻り値とするので、変数greetingに代入された"ありがとうございました。”が戻り値となります。
    - COLUMN メソッドの()は省略可能
        - def6.rbでarea(2)とメソッド呼び出しを書きました。ここで()を省略してarea 2と書くこともできます。曖昧ではない範囲でメソッドの()は省略することができるのです。「曖昧ではない」は「別の解釈ができない」とも言えます。曖昧な時はエラーが出るので、その時は省略せずに()を書いて試してみてください。
        - また、引数がないメソッドの呼び出しにも()を付けることができます。例えば、def3.rbのareaをarea()と書くことができます。
        - メソッド呼び出しの()だけでなく、定義に書いている()も省略可能です。def6.rbのdef area(x)をdef area xと書くこともできます。呼び出しの()は省略されることも多いことに対して、定義の()はあまり省略されないことが多いようです。ただし、引数が0この時だけは、定義の()も省略して書くことが多いです。
        - さて、実はこれまでも()を省略した書き方でメソッド呼び出ししていたものがあります。
        
        ```ruby
        puts 1
        
        p 1
        ```
        
        - putsメソッドやpメソッドです。putsメソッドの後ろに書いていたオブジェクト(ここでは1)は、()を省略して引数としてputsメソッドへ渡しています。puts 1はputs(1)の()を省略したものです。
    - 📍まとめ
        - 引数を持つメソッドの定義
        
        ```ruby
        def メソッド名(引数1, 引数2, ......)
        	処理
        end
        ```
        
        - 引数を渡すメソッド呼び出し
        
        ```ruby
        メソッド名(引数1, 引数2, ......)
        ```
        
        - メソッド定義で引数を設定すると、呼び出し元からメソッドへオブジェクトを渡すことができる。
        - returnを実行すると、そこでメソッドの処理を終えることができる。
        - returnが実行された時は、returnに続いて書いたオブジェクトが戻り値となる。
- 7-3 引数の便利な機能を使う
    
    引数を使うとメソッドにオブジェクトを渡すことができることを見てきました。この節では、その引数を便利に活用する仕組みであるデフォルト値とキーワード引数を説明します。
    - 引数を省略した時のデフォルト値
    - 注文したい品物を引数で指定すると、「カフェラテをください」のように「〜〜をください」という文字列を返してくれるorderメソッドを定義してみましょう。
    
    ```ruby
    def order(item)
    	"#{item}をください"
    end
    
    puts order("カフェラテ")
    puts order("モカ")
    ```
    
    ```ruby
    カフェラテをください
    モカをください
    ```
    
    - **メソッドの引数には、デフォルト値を指定することができます**。**デフォルト値とは、引数を省略してメソッドが呼び出された時に使われる値です**。デフォルト値を指定するには、メソッド定義で**引数 = デフォルト値**と書きます。
    
    ```ruby
    def order(item = "コーヒー")
    	"#{item}をください"
    end
    
    puts order # 引数を省略して呼び出すと"コーヒーをください"が返される
    puts order("カフェラテ")
    puts order("モカ")
    ```
    
    ```ruby
    コーヒーをください
    カフェラテをください
    モカをください
    ```
    
    - 引数の順番を変えられるキーワード引数
    - 品物を指定して注文するプログラムを、サイズも指定できるように変更します。
    
    ```ruby
    def order(item, size)
    	"#{item}を#{size}サイズでください"
    end
    
    puts order("カフェラテ", "ベンティ")
    puts order("ベンティ", "カフェラテ") # 引数の順番を間違えた
    ```
    
    ```ruby
    カフェラテをベンティサイズでください
    ベンティをカフェラテサイズでください # 変な文になってしまった
    ```
    
    - 引数を渡す順番を直せばよいのですが、このプログラムだと、itemが先、sizeが後、と順番を覚えておく必要があります。引数の数がさらに増えれば、正しい順番を覚えることがもっと難しくなっていきます。こんな時は、キーワード引数を使うと問題を解決できます。**メソッド定義で引数名の後ろに`:`をつけると、キーワード引数になります**。**キーワード引数を使うと、メソッドを呼び出す時に引数を名前(キーワード)付きで指定できます**。先程のプログラムをキーワード引数を使って書き換えてみましょう。
    
    ```ruby
    def order(item:, size:) # 引数名の後ろに:を付けるとキーワード引数になる
    	"#{item}を#{size}サイズでください"
    end
    
    puts order(item: "カフェラテ", size: "ベンティ") # 引数を名前付きで指定できる
    puts order(size: "ベンティ", item: "カフェラテ") # 引数の順番も変えられる
    ```
    
    ```ruby
    カフェラテをベンティサイズでください
    カフェラテをベンティサイズでください
    ```
    
    - キーワード引数を使ったメソッドを呼び出す時は`order(item: “カフェラテ”, size: “ベンティ”)`のように書きます。呼び出しの書き方を覚える時は、{}を省略したハッシュと同じと考えてみてください。キーワード引数は、引数の順序を変えても呼び出せるという大きなメリットがあります。
    - キーワード引数を使うと引数をラベルのように書け、引数の指定順序も変えられます。プログラムが読みやすくなるメリットがあるので、引数が2つ以上になった時は利用を検討してみてください。もちろん、引数が1つの時にも使えますが、プログラムが長くなるデメリットもあります。普通の引数とキーワード引数と、どちらか良い方を選んで使ってください。
    - キーワード引数でのデフォルト値
    - キーワード引数でもデフォルト値を使うことができます。キーワード引数にデフォルト値を設定する時は、`引数名: デフォルト値`のように書きます。イコール(=)は書きませんので気を付けてください。
    
    ```ruby
    def order(item:, size: "ショート") # sizeのデフォルト値に"ショート"を設定
    	"#{item}を#{size}サイズでください"
    end
    
    puts order(item: "カフェラテ") # 省略するとデフォルト値が使われる
    puts order(item: "カフェラテ", size: "ベンティ")
    ```
    
    ```ruby
    カフェラテをショートさいずでください
    カフェラテをベンティサイズでください
    ```
    
    - 📍まとめ
    - メソッド定義デフォルト値あり
    
    ```ruby
    def メソッド名(引数1 = デフォルト値1, 引数2 = デフォルト値2, ......)
    	処理
    end
    ```
    
    - メソッド定義キーワード引数
    
    ```ruby
    def メソッド名(引数1: デフォルト値1, 引数2: デフォルト値2, ......)
    	処理
    end
    ```
    
    - メソッド呼び出しキーワード引数
    
    ```ruby
    メソッド名(引数1: オブジェクト1, 引数2: オブジェクト2, ......)
    ```
    
    - 引数にデフォルト値を設定すると、メソッドの呼び出し時に引数を省略できる。
    - キーワード引数を使うと、メソッドの呼び出し時に引数を名前付きで指定できる。
    - キーワード引数を使うと、メソッドの呼び出し時に引数を書く順番を変えられる。
- 7-4 変数には見える範囲がある
    
    ここまででメソッドを作る方法を見てきました。メソッドは処理のかたまりを独立させて名前を付けたものです。メソッドでは、変数にも処理を独立させるための工夫がされています。
    - ローカル変数とスコープ
    - メソッドを使うと、処理のかたまりを独立させることができます。できるだけ独立させたいので、「うっかり同じ名前の変数を使っちゃって動きが変になっちゃった！」といった問題は起きない方が親切です。このような問題を防ぐために、メソッドの中と外とで変数の見える範囲を制限する機能が付いています。
    
    ```ruby
    def hello
    	text = "こんにちは" # ①ここで変数に文字列を代入して
    	p text # ②ここで変数を使う
    end
    
    hello
    ```
    
    ```ruby
    "こんにちは"
    ```
    
    ```ruby
    def hello
    	text = "こんにちは" # ①ここで変数に文字列を代入して
    end
    
    hello
    p text # ②ここで変数を使う
    ```
    
    ```ruby
    variable2.rb:6:in `<main>': undefined local variable or method `text'
    	for main:Object (NameError)
    ```
    
    - プログラムを実行すると、②のtext変数を使おうとするところでエラーになりました。「textという変数またはメソッドは定義されていない」というエラ〜メッセージが出ています。実は、メソッド内で定義した変数は、メソッドの外からは見えません。helloメソッドないの変数textは、メソッドの外からは使えないのです。また、helloメソッドの実行が終わると、メソッド内の変数textと、それが指す文字列オブジェクト"こんにちは”は役目を終えて破棄されます。
    - このように、変数には見える範囲と寿命があります。変数の見える範囲とじゅ目用のことを、「スコープ」と言います。ここまでに出てきた変数たちはローカル変数と呼ばれます。スコープが最も狭い変数です。
    - メソッド内のローカル変数はメソッドの外からは見えませんでした。では逆のパターン、メソッドの外で定義されたローカル変数はメソッド内で見ることができるのでしょうか？
    
    ```ruby
    text = "こんにちは" # ①ここで変数に文字列を代入して
    
    def hello
    	p text # ②ここで変数を使う
    end
    
    hello
    ```
    
    ```ruby
    variable3.rb:4:in `hello': underfined local variable or method `text'
    	for main:Object (NameError)
     from variable3.rb:7:in `<main>'
    ```
    
    - ②の`text`変数を使おうとするところで、「`text`という変数またはメソッドは定義されていない」というエラーになります。メソッドの外に書いてある変数も、メソッドの中では見えません。メソッドの中で必要なオブジェクトは、引数を使って渡します。
    - 📍まとめ
        - 変数にはスコープ(見える範囲と寿命)がある。
        - ローカル変数は、定義したメソッドの中がスコープになり、メソッドの外では見えない。
        - 同様に、メソッドの外で定義したローカル変数は、メソッドの中では見えない。
- 7-4 変数には見える範囲がある
    
    ここまででメソッドを作る方法を見てきました。メソッドは処理のかたまりを独立させて名前を付けたものです。メソッドでは、変数にも処理を独立させるための工夫がされています。
    - ローカル変数とスコープ
    - メソッドを使うと、処理のかたまりを独立させることができます。できるだけ独立させたいので、「うっかり同じ名前の変数を使っちゃって動きが変になっちゃった！」といった問題は起きない方が親切です。このような問題を防ぐために、メソッドの中と外とで変数の見える範囲を制限する機能が付いています。
    
    ```ruby
    def hello
    	text = "こんにちは" # ①ここで変数に文字列を代入して
    	p text # ②ここで変数を使う
    end
    
    hello
    ```
    
    ```ruby
    "こんにちは"
    ```
    
    ```ruby
    def hello
    	text = "こんにちは" # ①ここで変数に文字列を代入して
    end
    
    hello
    p text # ②ここで変数を使う
    ```
    
    ```ruby
    variable2.rb:6:in `<main>': undefined local variable or method `text'
    	for main:Object (NameError)
    ```
    
    - プログラムを実行すると、②のtext変数を使おうとするところでエラーになりました。「textという変数またはメソッドは定義されていない」というエラ〜メッセージが出ています。実は、メソッド内で定義した変数は、メソッドの外からは見えません。helloメソッドないの変数textは、メソッドの外からは使えないのです。また、helloメソッドの実行が終わると、メソッド内の変数textと、それが指す文字列オブジェクト"こんにちは”は役目を終えて破棄されます。
    - このように、変数には見える範囲と寿命があります。変数の見える範囲とじゅ目用のことを、「スコープ」と言います。ここまでに出てきた変数たちはローカル変数と呼ばれます。スコープが最も狭い変数です。
    - メソッド内のローカル変数はメソッドの外からは見えませんでした。では逆のパターン、メソッドの外で定義されたローカル変数はメソッド内で見ることができるのでしょうか？
    
    ```ruby
    text = "こんにちは" # ①ここで変数に文字列を代入して
    
    def hello
    	p text # ②ここで変数を使う
    end
    
    hello
    ```
    
    ```ruby
    variable3.rb:4:in `hello': underfined local variable or method `text'
    	for main:Object (NameError)
     from variable3.rb:7:in `<main>'
    ```
    
    - ②の`text`変数を使おうとするところで、「`text`という変数またはメソッドは定義されていない」というエラーになります。メソッドの外に書いてある変数も、メソッドの中では見えません。メソッドの中で必要なオブジェクトは、引数を使って渡します。
    - 📍まとめ
    - 変数にはスコープ(見える範囲と寿命)がある。
    - ローカル変数は、定義したメソッドの中がスコープになり、メソッドの外では見えない。
    - 同様に、メソッドの外で定義したローカル変数は、メソッドの中では見えない。</details>

**<details><summary>CHAPTER 8 部品を作る - クラス</summary>**
この章ではプログラムを整理して書くための仕組みであるクラスを説明します。これまでに出てきたオブジェクトがクラスに属していること、自分でもクラスを作ることができることを説明します。この章を学ぶと、新しいクラスを作れるようになり、違った特徴を持った新しい種族のオブジェクトを作れるようになります。
- 8-1 クラスとは
    
    ここまでで整数オブジェクト、文字列オブジェクトなど、いろいろな種類のオブジェクトを扱ってきました。このオブジェクトごとの違い、その種類を決めている仕組みが「クラス」です。クラスとはどういうものなのかを見ていきましょう。
    - オブジェクトはクラスに属している
        - クラスとは「オブジェクトの種族を表すもの」です。全てのオブジェクトは、いずれかのクラスに属しています。どのクラスに属しているかは、classメソッドで調べることができます。

        ```ruby
        p 1.class #=> Integer
        p 2.class #=> Integer
        p 100.class #=> Integer

        p "カフェラテ".class #=> String
        p "hello".class #=> String
        p "".class #=> String

        p [1, 2, 3].class #=> Array
        p ["コーヒー", "カフェラテ"].class #=> Array
        p [].class #=> Array
        ```

        - classメソッドの結果から、**1**、**2**、**100**といったオブジェクトたちは**Integer(整数)クラス**に属する、同じ種族であることが分かります。同様に**”カフェラテ”**、**”hello”**、**””**たちは**Stringクラス**の一族、**[1, 2, 3]**、**[”コーヒー”, “カフェラテ”]**、**[]**たちは**Arrayクラス**の一族です。
        - クラスの属するオブジェクトを、そのクラスの「インスタンス」であるとも言います。インスタンスはオブジェクトとほぼ同じ意味で使いますが、「クラスから作ったオブジェクトである」「そのクラスに属する」ということを強調したい時に使います。
        - オブジェクトは、所属するクラスが用意しているメソッドを使うことができます。例えばIntegerでは、偶数かどうかを判断するeven?メソッドです。
    
        ```ruby
        p 1.even? #=> false
        p 2.even? #=> true
        p 100.even? #=> true
        ```

        - even?メソッドを実行すると、1は奇数なのでfalseを返し、2と100は偶数なのでtrueを返します。
        - 一方で、”hello”はString、[1, 2, 3]はArrayクラスに属するオブジェクトです。例えば、先程のeven?は、Stringなどの他のクラスに属するオブジェクトでは使えません。

        ```ruby
        p 1.even? #=> false
        p "カフェラテ".even? #=> NoMethodError (undefined nethod `even?' for "カフェラテ":String)
        ```

        - **“カフェラテ”はStringクラスに属するオブジェクトで、Integerクラスには属していません。なので、Integerクラスで用意されているeven?メソッドを使おうとしてもエラーになるのです**。
        - クラスはオブジェクトの種族を表すものです。ということは、クラスを作れば新しい種族を自分で作るということになります。

    - COLUMN リファレンスマニュアルはクラスごとに書かれている
        - **リファレンスマニュアルはクラスごとにメソッドの一覧が書かれています。もしも、クラスの分からないオブジェクトの持つメソッドを調べたい時は、classメソッドでクラスを調べれば、リファレンスマニュアルでそのクラスを探すことができます**。
    - オブジェクトを作る2つの方法
        - 例えば次のように書くことでオブジェクトを作ることができます。

        ```ruby
        p "カフェラテ" # Stringオブジェクト
        p [1, 2, 3] # Arrayオブジェクト
        ```

        - これらの書き方のほかに、**クラス**と`new`メソッドを使ってオブジェクトを作る方法もあります(ただし、**Integerクラスのようにnewメソッドが用意されていないクラスもあります**)。

        ```ruby
        p String.new #=> "" 空文字列を作成
        p String.new("カフェラテ") #=> "カフェラテ" 文字列であるオブジェクトを作成
        p Array.new #=> [] 空配列を作成
        p Array.new(2, "カフェラテ") #=> ["カフェラテ", "カフェラテ"] newメソッドの引数に個数(2)と要素にするオブジェクト("カフェラテ")を渡すと、そのオブジェクトを指定した個数だけを持った配列オブジェクトを作成
        ```

        - オブジェクト作成

        ```ruby
        クラス.new #=> そのクラスのオブジェクト
        ```

        - クラスの`new`メソッドを呼び出すことで、**そのクラスのオブジェクト(インスタンス)を作ることができます**。`String.new`を実行すると、**空であるStringクラスのオブジェクト、つまり空文字列を作ります**。`String.new("カフェラテ")`のように**newメソッドの引数に文字列を渡すと、その文字列であるオブジェクトを作ります**。`Array.new`を実行すると、**空であるArrayクラスのオブジェクト、つまりから配列を作ります**。**Arrayのnewメソッドへ引数に個数(2)と要素にするオブジェクト(”カフェラテ")を渡すと、そのオブジェクトを指定した個数だけ持った配列オブジェクトを作ります**。
        - ここまでで、出てきたクラスでは`new`を使わずに書く方が便利なのでそちらがよく使われます。
    - 📍まとめ
        - **そのオブジェクトの属するクラスを表示する**

        ```ruby
        オブジェクト.class
        ```

        - **そのクラスのオブジェクトを作成する**

        ```ruby
        クラス.new
        ```

        - クラスはオブジェクトの種族を表すもの。
        - 全てのオブジェクトは、いずれかのクラスに属す。
        - オブジェクトがどのクラスに属しているかは、`class`メソッドで調べることができる。
        - クラスの属するオブジェクトを、そのクラスの「**インスタンス**」であるともいう。
        - `new`メソッドを使うと、そのクラスの**オブジェクト**(**インスタンス**)を作ることができる。
- 8-2 クラスを作る
    
    オブジェクトはクラスごとにいろいろな特徴を持っています。新しいクラスを作ることで、新しい特徴を持ったオブジェクトを作ることもできます。

    - クラスを作る
        - Rubyにはたくさんのクラスが用意されています。Integer(整数)クラスやFloat(少数)クラスは計算の場面で、String(文字列)クラスは単語や文章を扱う場面で、Array(配列)クラスやHashクラスは複数のオブジェクトを一緒に扱う場面で使うことができます。
        - そして、**クラスは自分で作ることもできます**。**クラスを作ってプログラムを書くと、大規模なプログラムを設計して書くことができるようになります**。例えば、**Ruby on Railsで書かれたWebアプリケーションではクラスの仕組みは欠かせません**。既にあるクラスと、自分で作ったたくさんのクラスを使って、適材適所でオブジェクトへ仕事を割り振りプログラムを書いていきます。
        - クラスを作ることをクラスを定義すると言います。メソッドと同じです。

        ```ruby
        class Drink
        end
        ```

        ```ruby
                                # 何も表示されません
        ```

        - クラスの定義

        ```ruby
        class クラス名
        end
        ```

        - クラスは定義するだけでは何も目に見える処理をしないので、実行しても何も表示されません。
        - **クラスを定義しただけでもnewメソッド、classメソッドなどの基本的なメソッドが既に使えるようになっています**。
        - ここで作ったDrinkクラスのオブジェクトを作ります。そして、classメソッドを使ってそのオブジェクトのクラスがDrinkであることを確認してみましょう。

        ```ruby
        class Drink
        end

        drink = Drink.new # ①newメソッドでそのクラスのオブジェクトを作り、変数drinkへ代入
        p drink.class #=> Drink ②
        ```

        ```ruby
        Drink
        ```

        - ①では、newメソッドでDrinkクラスのオブジェクトを作り、変数drinkに代入しています。言い換えると、作ったDrinkクラスのオブジェクトにdrinkという名前を付けているとも言えます。
        - ②で変数drinkが指すオブジェクトのクラスをclassメソッドで表示させると、Drinkと表示され、属するクラスがDrinkであることを確認できます。また、最後の2行は変数へ代入せずに、**メソッドチェイン**を使って1行で`p Drink.new.class`と書くこともできます。
        - ここで気を付けるべきことは、大文字始まりのDrinkは**クラス名**、小文字始まりのdrinkは**変数名**で、**別のものであること**です。
        - クラスはnewメソッドを使うことでそのクラスのオブジェクトを作ることができます。クラスはその種類のオブジェクトを作ることができる工場のようなものです。そのクラス自身が仕事をすることもあれば、そのクラスから作ったオブジェクトが仕事をすることもあります。
    - クラス名の規則
        - クラス名は、**Drink**、**Item**のように**先頭を大文字で始めます**。慣習として、2文字目以降は小文字にして、2単語以上を組み合わせた名前にする場合はCaffeLatteのように区切り文字を大文字にして繋ぎます。このようなスタイルを**キャメルケース**と言います。大文字がラクダ(camel)のコブのように見えるからです。
        - 定数も大文字から始まっていました。実はクラスの名前も定数です。クラスを定義すると、クラス名の定義が作られます。Drinkクラスを定義すると、Drinkという定数が作られます。
        - 定数は、変数のように代入できますが、2回目に代入しようとするとwarningが出ます。定数は固定しておくものなので、変更しようとすると「意図通りですか？」とwarningが表示されて教えてくれます。
    - COLUMN クラスも実はオブジェクト
        - クラスそのものもオブジェクトです。オブジェクトなので次のようにクラスへ続けてclassメソッドを呼び出すと、どのクラスの属しているかが表示されます。

        ```ruby
        class Drink
        end

        p Drink.class #=> Class
        ```

        - クラスはClassクラスのオブジェクトであることが分かります。
    - 📍まとめ
        - クラスを定義する

        ```ruby
        class クラス名
        end
        ```

        - そのクラスのオブジェクトを作る

        ```ruby
        クラス.new #=> そのクラスのオブジェクト
        ```

        - クラス名は先頭を大文字で始める。
        - クラス名は2単語以上繋げた名前にする時はCaffeLatteのように区切り文字を大文字にして繋ぐ(キャメルケース)。
- 8-3 オブジェクトが呼び出せるメソッドを作る
    
    クラスにメソッドを定義すると、そのクラスに属するオブジェクトたちはそのメソッドを呼び出すことができます。クラスに新しいメソッドを作ることは、ゲームのRPGで例えると、キャラクターが新しい呪文を覚えることに相当します。キャラクターが呪文を覚えるとできることが増えるように、オブジェクトもメソッドが呼び出せるようになると、できることが増えていきます。メソッドを作って、オブジェクトにできることを増やしていきましょう。
    - クラスにメソッドを定義する
        - クラスへメソッドを追加していくことで、欲しい機能を持ったクラスを育てていくことができます。最初は、名前を返す**name**メソッドを、クラスDrinkで定義してみましょう。

        ```ruby
        class Drink
            def name # Drinkクラスへnameメソッドを定義
                "カフェラテ"
            end
        end
        ```

        ```ruby
                                # 何も表示されません
        ```

        - `class Drink`から対応する`end`までの間に書くと、この**name**メソッドはDrinkクラスのメソッドとして定義されます。また、**メソッドを定義しただけでは動きません**。このプログラムではDrinkクラスのnameメソッドを定義していますが、呼び出していないので何も出力されません。
        - クラスでのメソッド定義

        ```ruby
        class クラス名
            def メソッド名
            end
        end
        ```
    
    - クラスに定義したメソッドを呼び出す
        - Drinkクラスのnameメソッドが名前”カフェラテ"を返すように書けました。次はDrinkクラスのオブジェクトを作り、nameメソッドを呼び出してみましょう。

        ```ruby
        class Drink
            def name
                "カフェラテ"
            end
        end

        drink = Drink.new # ①Drinkクラスのオブジェクトを作って変数drinkへ代入
        puts drink.name #=> カフェラテ ②Drinkクラスのオブジェクトのnameメソッドを呼び出す
        ```

        ```ruby
        カフェラテ
        ```

        - メソッドの呼び出し

        ```ruby
        オブジェクト.メソッド
        ```

        - **①ではDrinkクラスのオブジェクトを作成して、変数drinkへ代入しています**。drinkと名付けたDrinkクラスのオブジェクトに対して、**②ではdrink.nameでnameメソッドを呼び出しています**。
        - **メソッドを呼び出すには、オブジェクトに対して.メソッド**と書きます。**オブジェクトが変数に代入されている時には、今回のdrink.nameのように変数.メソッド**と書きます。
        - **クラスの定義したメソッドは、そのクラスに属する全てのオブジェクトで呼び出すことができます**。**クラスにメソッドを定義しておけば、そのクラスからオブジェクトを作って、そのオブジェクトたち全員でそのメソッドを呼ぶことができるのです**。
    - レシーバ
        - **「メソッドを呼び出されるオブジェクト」のことを「レシーバ」と呼びます**。ここでのレシーバは「（変数drinkに代入された)Drinkクラスのオブジェクト」です。
        - 前に出てきた2.even?では、even?メソッドのレシーバは2(整数オブジェクト)です。[”カフェラテ", “モカ", “コーヒー”].sizeのsizeメソッドのレシーバは[”カフェラテ", “モカ", “コーヒー”](配列オブジェクト)です。
    - COLUMN methodsメソッド
        - methodsメソッドを使うと、レシーバであるオブジェクトで呼び出せるメソッドを一覧表示することができます。

        ```ruby
        p 1.methods
        ```

        ```ruby
        [:!, :!=, :!~, :%, :&, :*, :**, :+, :+@, :-, :-@, :/, :<, :<<, :<=, :<=>, :==, :===, :=~, :>, :>=, :>>, :[], :^, :__id__, :__send__, :abs, :abs2, :allbits?, :angle, :anybits?, :arg, :between?, :bit_length, :ceil, :chr, :clamp, :class, :clone, :coerce, :conj, :conjugate, :define_singleton_method, :denominator, :digits, :display, :div, :divmod, :downto, :dup, :enum_for, :eql?, :equal?, :even?, :extend, :fdiv, :finite?, :floor, :freeze, :frozen?, :gcd, :gcdlcm, :hash, :i, :imag, :imaginary, :infinite?, :inspect, :instance_eval, :instance_exec, :instance_of?, :instance_variable_defined?, :instance_variable_get, :instance_variable_set, :instance_variables, :integer?, :is_a?, :itself, :kind_of?, :lcm, :magnitude, :method, :methods, :modulo, :negative?, :next, :nil?, :nobits?, :nonzero?, :numerator, :object_id, :odd?, :ord, :phase, :polar, :positive?, :pow, :pred, :private_methods, :protected_methods, :public_method, :public_methods, :public_send, :quo, :rationalize, :real, :real?, :rect, :rectangular, :remainder, :remove_instance_variable, :respond_to?, :round, :send, :singleton_class, :singleton_method, :singleton_method_added, :singleton_methods, :size, :step, :succ, :taint, :tainted?, :tap, :then, :times, :to_c, :to_enum, :to_f, :to_i, :to_int, :to_r, :to_s, :truncate, :trust, :untaint, :untrust, :untrusted?, :upto, :yield_self, :zero?, :|, :~]
        ```

        - Integerクラスのオブジェクトである1には、たくさんのメソッドが用意されています。**結果は配列で得られる**ので、探しづらい時は`1.methods.sort`と**sort**メソッドを使えばabc順に並び見つけやすくなります。
    - クラスに引数を受け取るメソッドを定義する
        - クラスに定義するメソッドにも引数でオブジェクトを渡すことができます。Drinkクラスにorderメソッドを定義して、引数を使って注文する商品を渡すようにしてみましょう。

        ```ruby
        class Drink
            def order(name) # 引数として受け取ったオブジェクトを変数nameへ代入
                puts "#{name}をください"
            end
        end

        drink = Drink.new # Drinkクラスのオブジェクトを作って変数drinkへ代入
        drink.order("カフェラテ") # orderメソッドを呼び出して引数で"カフェラテ"を渡す
        ```

        ```ruby
        カフェラテをください
        ```

        - orderメソッドを、引数を受け取れるように定義しました。drink.order(”カフェラテ")と呼び出すことで、orderメソッドへ文字列オブジェクト"カフェラテ"を渡しています。orderメソッドの中では変数nameを使って、「カフェラテをください」と表示しています。
    - クラスの中で同じクラスのメソッドを呼び出す
        - クラスに複数のメソッドを定義することもできます。クラスに複数のメソッドを定義して、そのうちの1つのメソッドから、別のメソッドを読んでみましょう。次の例は、Drinkクラスにnameメソッドとtoppingメソッドを定義しています。そしてnameメソッドを呼び出し、nameメソッドの中でさらにtoppingメソッドを呼び出し、戻り値であるトッピングを加えて返すプログラムです。

        ```ruby
        class Drink
            def name
                "モカ" + topping # ①同じクラスのtoppingメソッドを呼び出し
            end
            def topping
                "エスプレッソショット"
            end
        end

        drink = Drink.new # ②
        puts drink.name #=> モカエスプレッソショット ③
        ```

        ```ruby
        モカエスプレッソショット
        ```

        - **Drink**クラスに**name**メソッドと**topping**メソッドを定義しています。**name**メソッドの中で、同じクラスの**topping**メソッドを呼んで、その戻り値を利用しています。このように、**クラスに定義されたメソッドの中で同じクラスの他のメソッドを呼ぶ時は、メソッド名をそのまま書くことで呼び出せます**。
        - ③の**drink.name**は、「**オブジェクト.メソッド名**」の形式で、レシーバを指定したメソッド呼び出しです。クラス定義の外側でメソッドを呼び出す時は、このようにレシーバとなるオブジェクトに対してメソッドを呼び出します。
        - 一方で、クラスに定義されたメソッド中の①の**topping**メソッドの呼び出しはレシーバの部分がありません。メソッド名である**topping**だけが書かれています。これは、**レシーバと.を省略した書き方**です。**省略すると、実行中のメソッドのレシーバに対してメソッドを呼び出します**。**toppingメソッドのレシーバは、実行中のnameメソッドのレシーバである③のdrink、つまり②で作られたDrinkクラスのオブジェクトです**。
    - selfを使ってレシーバを調べる
        - レシーバがどのオブジェクトかを把握することは、慣れるまでは少し難しいかもしれません。レシーバが何かが分からない時には、selfを使うと調べることができます。selfは、その場所でメソッドを呼び出したときのレシーバを返します。ここではtoppinメソッドのレシーバを調べるために、前の行でselfを調べてみましょう。

        ```ruby
        class Drink
            def name
                p self # ②selfでレシーバを取得
                "モカ" + topping
            end
            def topping
                "エスプレッソショット"
            end
        end

        drink = Drink.new 
        p drink # ①
        puts drink.name
        ```

        ```ruby
        #<Drink:0x000000010774d1e8> # ①で表示したdrinkオブジェクト
        #<Drink:0x000000010774d1e8> # ②でselfで取得したレシーバ
        モカエスプレッソショット
        ```

        - 実行結果から、①で表示した**drink**オブジェクトと、②の**self**で取得したオブジェクトは同じことが分かります。実行結果にある**#<Drink:0x000000010774d1e8>**の**Drink**はそのオブジェクトのクラスを示します。**:**に続く文字列はそのオブジェクトの識別番号で、これが同じであればオブジェクトです。
        - **topping**メソッドのレシーバは、①で表示した**Drink**クラスのオブジェクトであることが分かりました。また、**self**でレシーバを取得できることを利用して、この**topping**メソッドをレシーバを省略せずに**オブジェクト.メソッド名**の形式で書くと、**self.topping**と書けます。
    - 📍まとめ
        - クラスにメソッドを定義する

        ```ruby
        class クラス名
            def メソッド名
            end
        end
        ```

        - メソッドを呼び出す

        ```ruby
        オブジェクト.メソッド
        ```

        - クラスにメソッドを定義する時は、classクラス名からendの間にdefでメソッドを書く。
        - クラスのメソッドを呼び出す時は、そのクラスのオブジェクトへ続けて**.メソッド名**と書く。
        - **メソッドが呼び出されるオブジェクトを「レシーバ」と呼ぶ**。
        - クラスの中でメソッドを呼び出す時はレシーバを省略してメソッド名だけで呼び出せる。
- 8-4 オブジェクトにデータを持たせる
    
    オブジェクトはデータを持つことができます。オブジェクトは覚えたデータに応じて異なる動作もできるようになり、できることが増えていきます。
    
    - インスタンス変数
        - インスタンス変数はローカル変数よりも広いスコープを持ちます。
        - インスタンス変数はその名の通り、インスタンス(オブジェクト)を持つ変数です。ローカル変数と違って同じオブジェクトであれば、複数のメソッドを跨いで使うことができます。寿命もオブジェクトと同じになり、オブジェクトが存在する間ずっとインスタンス変数を使うことができます。
        - インスタンス変数は、変数名の先頭に@を付けることで作ることができます。

        ```ruby
        class Drink
          def order(item)
            puts "#{item}をください"
            @name = item ③
          end
          def reorder
            puts "#{@name}をもう1杯ください" ⑤
          end
        end

        drink = Drink.new ①
        drink.order("カフェラテ") ②
        drink.reorder ④
        ```

        - drink = Drink.newでDrinkクラスのオブジェクトを作ります①。そのオブジェクトのorderメソッドを呼び出し②、メソッドでの処理でインスタンス変数@nameへ”カフェラテ”を代入します③。続いて同じオブジェクトのreorderメソッドを呼び出します④。インスタンス変数@nameには③で”カフェラテ”が代入されているので、”#{@name}をもう1杯ください”は”カフェラテをもう1杯ください”となります⑤。
        - インスタンス変数は代入が実行された時に生まれます。もしも代入されていないインスタンス変数を使おうとするとnilになるので注意してください。インスタンス変数の寿命はそれを持つオブジェクトの寿命と同じになります。先程のプログラムでは①のDrink.newで作られたオブジェクトがインスタンス変数@nameの持ち主で、このオブジェクトが存在する間はインスタンス変数@nameも存在して使うことができます。
    - インスタンス変数はオブジェクトごとに存在する
        - インスタンス変数は、インスタンス、つまりオブジェクトごとに存在する変数です。オブジェクトが別ならば、別のインスタンス変数になります。

        ```ruby
        class Drink
          def order(item)
            puts "#{item}をください"
            @name = item
          end
          def reorder
            puts "#{@name}をもう1杯ください"
          end
        end

        drink1 = Drink.new ①
        drink2 = Drink.new ②
        drink1.order("カフェラテ") ③
        drink2.order("モカ") ④
        drink1.reorder ⑤
        drink2.reorder ⑥
        ```

        ```ruby
        カフェラテをください # ③の結果
        モカをください # ④の結果
        カフェラテをもう1杯ください # ⑤の結果
        モカをもう1杯ください # ⑥の結果
        ```

        - このプログラムではDrinkクラスのオブジェクトを①と②で2つ作ります。1つ目のオブジェクトはdrink1へ代入し、2つ目のオブジェクトはdrink2へ代入しておきます。③で1つ目のオブジェクトへは”カフェラテ”を、④で2つ目のオブジェクトには”モカ”をそれぞれ渡します。どちらもDrinkクラスのorderメソッドの中でインスタンス変数@nameへ代入しますが、オブジェクトが別なので、オブジェクトごとに別の変数@nameへと代入されます。⑤と⑥でreorderメソッドを実行すると、それぞれのオブジェクトの変数@nameに代入した文字列が表示され、オブジェクトごとに別のインスタンス変数となっていることがわかります。
    - インスタンス変数を取得するメソッドを作る
        - オブジェクトの外でインスタンス変数を取得するにはどうすれば良いでしょうか？

        ```ruby
        class Drink
          def order(item)
            puts "#{item}をください"
            @name = item
          end
        end

        drink = Drink.new
        drink.order("カフェラテ")
        # ① ここで@nameを取得したい
        ```

        - ①でdrinkオブジェクトが持つ@nameを取得したいのですが、オブジェクトの外なので、ただ@nameと書いただけでは取得できません。取得するためにはひと手間を加えて、Drinkクラスに@nameを戻り値とするメソッドを追加して、それを呼び出したます。

        ```ruby
        class Drink
          def order(item)
            puts "#{item}をください"
            @name = item
          end
          def name # ①
            @name # ②
          end
        end
    
        drink = Drink.new
        drink.order("カフェラテ")
        puts drink.name # ③
        ```

        ```ruby
        カフェラテをください
        カフェラテ
        ```

        - **①でnameメソッドを定義して、②で戻り値として@nameに代入されているオブジェクトを返します。③でdrink.nameの戻り値を画面に表示します**。
        - **インスタンス変数を取得するメソッドは、慣習的に「インスタンス変数名から@を取り除いたもの」にすることが多いです。今回のメソッド名も、インスタンス変数@nameを取得するので、そこから@を取り除いたnameという名前にしています**。
        - このnameメソッドを1行で定義できるattr_readerメソッドもあります。
    - インスタンス変数へ代入するメソッドを作る
        - インスタンス変数へ代入するメソッドも作ってみましょう。

        ```ruby
        class Drink
          def name=(text) # ①
            @name = text # ③
          end
          def name
            @name
          end
        end

        drink = Drink.new
        drink.name= "カフェオレ" # ②
        puts drink.name
        ```

        ```ruby
        カフェオレ
        ```

        - **①で、name=メソッドを定義しました。このメソッドは引数で渡したオブジェクトを@nameへ代入します。②でname=メソッドを呼び出し、引数として”カフェオレ”を渡しています。③で引数で渡された”カフェオレ”をインスタンス変数@nameへ代入しています。**
        - **インスタンス変数へ代入するメソッドは、慣習的に「インスタンス変数名から@を取り、末尾に=を加えたもの」にすることが多いです。今回のメソッド名も、インスタンス変数@nameへ代入するので、そこから@を取り除き末尾に=を加えたname=にしています。**
        - 慣習に従うとメリットがあります。メソッド呼び出し②の行は、次のように書くこともできます。

        ```ruby
        drink.name = "カフェオレ"
        ```

        - **name=メソッドを呼び出す時に、メソッド名のnameと=の間に半角スペースを開けて書くことができます。末尾が=で終わるメソッドはこのような書き方が可能です。このように書くと、インスタンス変数へ代入することを感覚的にわかりやすく示すことができます。**
    - instance_variablesメソッド
        - オブジェクトに対してinstance_variablesメソッドを呼び出すと、持っているすべてのインスタンス変数を返します。instance_variablesメソッドは、オブジェクトが持っているインスタンス変数の変数名一覧を取得するメソッドです。

        ```ruby
        class Drink
          def order(item)
            @name = item
          end
        end

        drink = Drink.new
        drink.order("カフェラテ")
        p drink.instance_variables
        ```

        ```ruby
        [:@name]
        ```

        - instance variables:**インスタンス変数**と訳す。
        - **instance_rariablesはオブジェクトのインスタンス変数名をシンボルの配列として返します。**
        - **インスタンス変数は代入した時に作られる**ので、drink.order(”カフェラテ")を実行しないとinstance_variablesメソッドが返すインスタンス変数の一覧に@nameが出てきません。
    - 📍まとめ
        - 名前が@で始まる変数はインスタンス変数。
        - インスタンス変数はローカル変数よりもスコープが広く、同じオブジェクトであればメソッドを跨いで使うことができる。
        - インスタンス変数はオブジェクトごとに持っている。
        - インスタンス変数は代入が実行された時に生まれる。
        - インスタンス変数の寿命はオブジェクトの寿命と同じになる。
        - メソッド名の末尾が=で終わるメソッドはdrink.name = “カフェラテ”のように=を話して書くことができる。
- 8-5 オブジェクトが作られるときに処理を行う
    
    インスタンス変数を使うとオブジェクトにデータを持たせることができます。これを一歩進めて、オブジェクトが作られる時に、インスタンス変数に最初からデータを持たせると便利なケースがあります。オブジェクトが作られる時に処理を実行させるinitializeメソッドの仕組みが用意されているので、これを使ってみましょう。
    
    - initializeメソッド
        - クラスにはinitializeという特別なメソッドが用意されています。**initializeという名前のメソッドを作ると、オブジェクトが新しく作られる時に自動で呼び出されます**。

        ```ruby
        class Drink
          def initialize # ①
            puts "新しいオブジェクト！"
          end
        end

        Drink.new # ②
        ```

        ```ruby
        新しいオブジェクト！
        ```

        - ①でinitializeメソッドを定義しています。②でnewメソッドが呼ばれるオブジェクトが作られますが、**その際にinitializeメソッドが自動で呼ばれます**。
        - 呼び出しているのはnewメソッドですが、自動で呼び出されるのはinitializeメソッドなので名前が違います。慣れるまでは少し戸惑うこともあるかもしれません。
    - インスタンス変数の初期値を設定する
        - initializeメソッドが便利な場面の例として、「インスタンス変数の初期値を設定する」があります。

        ```ruby
        class Drink
          def initialize
            @name = "カフェラテ" # ①
          end
          def name
            @name
          end
        end

        drink = Drink.new # ②
        puts drink.name # ③
        ```

        ```ruby
        カフェラテ
        ```

        - ②でDrink.newしてオブジェクトが作られる時にinitializeメソッドが呼ばれ、①でインスタンス変数@nameに”カフェラテ”が代入されます。③でnameメソッドを呼ぶと、戻り値は①で代入した”カフェラテ”になっています。
        - Drinkクラスのオブジェクトを作る時には、自動でインスタンス変数@nameに”カフェラテ”が代入されます。
    - initializeメソッドへ引数を渡す
        - 先程のプログラムで、Drinkクラスのオブジェクトを作ると@nameには初期値として"カフェラテ”が代入されるようになりました。では、この初期値を”カフェラテ"意外にも自由に設定するにはどうすればよいでしょうか？これは、initializeメソッドに引数を渡せるようにすることで解決できます。
        - initializeメソッドに引数を受け取るように定義して、newメソッドを呼び出す時にオブジェクトを渡すと、initializeメソッドで引数として受け取ることができます。

        ```ruby
        class Drink
          def initialize(name) # ①
            @name = name # ②
          end
          def name
            @name
          end
        end

        drink = Drink.new("モカ") # ③
        puts drink.name # ④
        ```

        ```ruby
        モカ
        ```

        - ①でinitializeメソッドに引数を受け取るように定義しています。③でnewメソッドを呼び出し、”モカ"を渡しています。initializeメソッドが呼ばれる時に、引数として変数nameに”モカ"が渡ってきます。②で引数で受け取ったオブジェクトを@nameへ代入します。④で@name変数の中身を表示させると、③で渡した”モカ"になっています。
        - **newメソッドを呼び出して引数を渡すと、initializeメソッドが呼び出されて引数として届くことが他のメソッドと違う点です**。ここで作ったDrinkクラスを使うと、newメソッドへ渡すオブジェクトを変えることで、いろいろなDrinkオブジェクトを作ることができます。

        ```ruby
        class Drink
          def initialize(name)
            @name = name
          end
          def name
            @name
          end
        end

        drink1 = Drink.new("カフェラテ")
        drink2 = Drink.new("コーヒー")
        drink3 = Drink.new("モカ")

        puts drink1.name #=> カフェラテ
        puts drink2.name #=> コーヒー
        puts drink3.name #=> モカ
        ```

    - 📍まとめ
        - initializeメソッドを定義しておくとオブジェクトが作られる時に自動で呼び出されて実行される。
        - initializeメソッドに引数を受け取るように定義しておくと、newメソッドを呼び出す時に引数を渡すことで、initializeメソッドで引数として受け取ることができる。
- 8-6 クラスを使ってメソッドを呼び出す
    
    ここまでで、クラスを使ってオブジェクトを作り、オブジェクトを使ってメソッドを呼び出せることを見てきました。別の種類のメソッドとして、オブジェクトを作らずに、クラスを使って呼び出せる「クラスメソッド」もあります。

    - インスタンスメソッドとクラスメソッド
        - クラスにはメソッドを作ることができることを学びました。実は、クラスに作るメソッドには2つの種類があります。ここまででクラスに定義してきたメソッドは「インスタンスメソッド」と呼ばれています。もう1つ、「クラスメソッド」と呼ばれるメソッドがあります。
        - 2つの違いは、「インスタンスをレシーバとするメソッド」と「クラスをレシーバとするメソッド」です。例を見てみましょう。
            - インスタンスメソッドの例

            ```ruby
            drink.name
            [1, 2, 3].size
            1.even?
            ```

            - クラスメソッドの例

            ```ruby
            Drink.new
            Array.new
            ```

        - インスタンスメソッドは、レシーバ(**.の前に書かれた、メソッドを呼び出すオブジェクト**)がインスタンス(**あるクラスのオブジェクトのこと**)であるメソッドです。前の節で作ったnameメソッドは、drink.nameとDrinkクラスのインスタンスに対して呼び出すインスタンスメソッドです。他にもたくさんありますが、例えば前に出てきた配列のsizeメソッドや、整数のeven?メソッドなどもインスタンスメソッドです。
        - **インスタンスメソッドは、インスタンスに対して呼び出します**。前の節のdrink.nameであればDrinkクラスのインスタンス(オブジェクト)に対してnameメソッドが呼び出されて、そのオブジェクトの@nameを返します。[1, 2, 3].sizeであれば、配列オブジェクト[1, 2, 3]のsizeメソッドが呼び出され、配列の要素数を返します。
        - 一方で、**クラスメソッドはレシーバがクラスであるメソッド**です。ここまで度々登場したnewメソッドはクラスメソッドです。Drink.newとクラス名に続いて呼び出します。
        - **クラスメソッドはクラスに対して呼び出します**。Drink.newであれば、Drinkクラスのnewメソッドを呼び出すと、Drinkクラスのオブジェクトを作る仕事をします。

        | クラスメソッド | インスタンスメソッド |
        | --- | --- |
        | Drink.new | drink.name |
        | レシーバがクラス | レシーバがインスタンス |
        | newメソッドはクラスメソッド | nameメソッドはインスタンスメソッド |

    - クラスメソッドを定義する
        - クラスメソッドを作ってみましょう。Cafeクラスに「いらっしゃいませ！」と返すwelcomeメソッドを定義します。

            ```ruby
            class Cafe
              def self.welcome # ①クラスメソッドを定義するときはメソッド名の前に self. を付ける
                "いらっしゃいませ！"
              end
            end

            puts Cafe.welcome # ②
            ```

            ```ruby
            いらっしゃいませ！
            ```

            ```ruby
            ◯クラスメソッドの定義
            def self.メソッド名
            end
            ```

            - クラスメソッドを定義するには、**defのメソッド名を書くところで、メソッド名の前にself.を付けます**①。クラスメソッドを呼び出すときは②のCafe.welcomeのように、**クラス名に続いて.メソッド名で呼び出すことができます**。**クラスメソッドはクラスが実行するのでオブジェクトを作ることなく呼び出すことができます**。

            ```ruby
            ◯クラスメソッドの呼び出し
            クラス名.メソッド名
            ```

            - インスタンスメソッドとクラスメソッド
    - COLUMN #記法と.記法
        - インスタンスメソッドとクラスメソッドをマニュアルなどで記述するときの記法があります。インスタンスメソッドは**クラス名#メソッド名**のように#記号を間に入れて書きます。例えば先程のnameメソッドは**Drink#name**となります。クラスメソッドは**クラス名.メソッド名**のように.記号を間に入れて書きます。例えば先程のwelcomeメソッドは**Cafe.welcome**と書きます。また、クラスメソッドは**::**を間に入れて**Cafe::welcome**とも書きます。
        - **これらの書き方はリファレンスマニュアルなどのドキュメントで出てくることもあるので、覚えておくと便利です**。

        ```ruby
        インスタンスメソッドの記法
        クラス名#メソッド名
        例 Drink#name

        クラスメソッドの記法
        クラス名.メソッド名
        例 Cafe.welcome

        クラス名::メソッド名
        例 Cafe::welcome
        ```

    - 同じクラスのクラスメソッドを呼び出す
        - クラスメソッドの中で同じクラスのクラスメソッドを呼ぶ時は、インスタンスメソッドの時と同じように、メソッド名だけを書けばOKです。または、レシーバを省略しない形で書くと、**self.クラスメソッド**または**クラス.クラスメソッド**となります。

        ```ruby
        class Cafe
          def self.welcome
            "いらっしゃいませ！"
          end
          def self.welcome_agein
            welcome + "いつもありがとうございます！" # クラスメソッドwelcomeを呼び出し
          end
        end

        puts Cafe.welcome_again #=> "いらっしゃいませ！いつもありがとうございます！"
        ```

        - そして、インスタンスメソッドからクラスメソッドを呼ぶこともできます。**`self.class.クラスメソッド`**または**`クラス.クラスメソッド`**という書き方をします。逆に、クラスメソッドからインスタンスメソッドを呼び出すことはできません。**クラスからは、レシーバとなるインスタンスを決めることができないから**です。
    - COLUMN クラスメソッドの別の定義方法
        - クラスメソッドの定義は`def self.メソッド名`と説明しましたが、別の書き方もあります。`class << self`と書いてからメソッドを定義します。**この書き方は、複数のクラスメソッドをまとめて書くのに便利です**。
        - class_method1.rbのCafeクラスをこの方法で書くと以下のようになります。

        ```ruby
        class Cafe
          class << self # クラスメソッド作成開始
            def welcome # welcomeメソッド作成し、以下の内容を実行する
              "いらっしゃいませ！"
            end # メソッド作成終了
          end # クラスメソッド作成終了
        end # クラス作成終了

        # クラスメソッドの定義は def self.メソッド名
        # クラスメソッドの定義の別の書き方 class << self と書いてからメソッドを定義する 今回は def welcome
        # この書き方は複数のクラスメソッドをまとめて書くのに便利
        ```

        - そのほか、`def クラス名.メソッド名`(今回のプログラムでは`def Cafe.welcome`)という書き方もありますが、これは**もしもクラス名を変えることになると、メソッド名も変更しないといけない短所があります**。最初に出てきた`def self.メソッド名`のselfは、実はクラスを返しています。クラス名を書く方法と同じスタイルですが、**selfを使って書くと、クラス名が変わった時に書き換えなくてよい長所があります**。
    - 📍まとめ
        - インスタンスメソッドはインスタンスに対して呼び出すメソッド。
        - クラスメソッドはクラスに対して呼び出すメソッド。
        - クラスメソッドは`def self.メソッド名`のようにメソッド名の前に`self.`を書いて定義する。
- 8-7 継承を使ってクラスを分ける
    
    カフェのメニューでは、扱っている商品を、ドリンクやフードなど種類別に分類して掲載しています。さらにドリンクの中ではコーヒー、紅茶、スムージーのように階層を作って分類されています。このような「種類別に階層を作って分類する」ことを、プログラムで表現する時には「継承」という仕組みが利用できます。ここでは継承を使ってクラスを作る方法を見ていきましょう。

    - 継承
        - 「種類別に階層を作って分類する」ことを、プログラムで表現する時には「継承」という仕組みが利用できます。
        - 題材として、カフェでの商品およびドリンクを、継承を利用して扱うプログラムを見てみましょう。実際のプログラム例を出して説明していきます。
        - 先ず、ケーキやマフィンといった商品を扱うItemクラスを作ります。Itemクラスは名前を設定して使うことができます。

        ```ruby
        class Item
          def name
            @name
          end
          def name=(text)
            @name = text
          end
        end
        ```

        - そして、ドリンクを扱うDrinkクラスを作ります。ドリンクでは名前に加えて、サイズの情報も持ちます。

        ```ruby
        class Drink
          def name
            @name
          end
          def name=(text)
            @name = text
          end
          def size
            @size
          end
          def size=(text)
            @size = text
          end
        end
        ```
    
        - **このItemクラスとDrinkクラスにおいて、nameメソッドとname=メソッドの内容は同じです**。また、**DrinkはItemの一種類という関係があります**。このような時には、「**継承**」の仕組みを使うと次のように書けます。

        ```ruby
        class Item
          def name
            @name
          end
          def name=(text)
            @name = text
          end
        end

        class Drink < Item # ①
          def size
            @size
          end
          def size=(text)
            @size = text
          end
        end

        item = Item.new
        item.name = "マフィン"

        drink = Drink.new
        drink.name = "カフェオレ" # ②
        drink.size = "tall"
        puts "#{drink.name} #{drink.size}サイズ"
        ```

        ```ruby
        カフェオレ tallサイズ
        ```
    
        - ①で`class Drink < Item`のようにクラスを定義すると、**Itemクラスを継承したDrinkクラスを作ることができます**。この**DrinkクラスはItemクラスの全てのメソッドを受け継ぎます**。つまり、**ここではItemクラスのnameメソッドとname=メソッドをDrinkクラスでも使うことができます**。②でDrinkクラスのオブジェクトへ呼び出しているname=メソッドは、親にあたるItemクラスのname=メソッドを使っています。
        - このようなItemクラスを使ったDrinkクラスの定義を「**Itemクラスを継承してDrinkクラスを定義する**」と言い、「**DrinkクラスはItemクラスを継承したクラス**」と言います。そして、**継承元であるItemクラスはスーパークラスと呼び**、**継承先であるDrinkクラスはサブクラスと呼びます**。継承先のクラスは、スーパークラスの全てのメソッドを受け継ぎます。また、**スーパークラスが親**、**サブクラスが子**と考えることもできるので、本書では**親クラス**、**子クラス**という呼び方もします。

        ```ruby
        ◯継承
        class クラス名 < スーパークラス名
        end
        ```

        | 継承元/継承先 | 親クラス、スーパークラス | 子クラス、サブクラス |
        | --- | --- | --- |
        | クラス名 | Itemクラス | Drinkクラス |
        | 定義 | class Item | class Drink < Item |
        | 使えるメソッド | name,name= | name,name=,size,size= |
        | 注釈 |  | 子クラスは、親クラスのメソッドを使うことができる |
    
    - COLUMN 親クラスと子クラスのどちらにメソッドを加えるか
        - 先程のプログラムへ加えて、価格を設定、取得するメソッドを加える場合を考えてみましょう。これは商品全般に共通するものです。親クラスであるItemクラスに書くことで、それを継承したDrinkクラスでも利用でき、重複せずに書くことができます。また、Itemクラスを継承した別のクラス(例えばFood)を作る時にも、Itemクラスに書かれたものを共同利用できます。
        - 一方でホットかアイスかを設定、取得するメソッドは、ドリンクに固有なもので、商品には不要そうです。このケースでは、Drinkクラスにメソッドを追加するのがよいでしょう。
    - Rubyが用意しているクラスたちの継承関係
        - 整数クラスIntegerや少数クラスFloatは、数値クラスNumericを継承して作られています。例えば、0可動化を判断するzero?メソッドはIntegerクラスやFloatクラスの親クラスであるNumericに定義されています。子クラスは親クラスのメソッドを呼び出すことができるので、IntegerクラスもFloatクラスもzero?メソッドを呼び出すことができます。
        - あるクラスの継承関係を見るにはancestorsメソッドを使います。**ancestorsメソッドは、そのクラスの継承関係(親クラス群)を表示するメソッドです**。クラスの家系図のようなものですね。親クラスのそのまた親クラス、というように、継承関係上の祖先をたどることができます。**より正確には、親クラスとincludeしているモジュールを表示します**。
        - ancestor:祖先、先祖

        ```ruby
        p Integer.ancestors
        # => [Integer, Numeric, Comparable, Object, Kernel, BasicObject]

        p Array.ancestors
        # => [Array, Enumerable, Object, Kernel, BasicObject]

        p Class.ancestors
        # => [Class, Module, Object, Kernel, BasicObject]
        ```

        - いくつかのクラスのancestorsを見ると、**どのクラスの祖先にもObject,Kernel,BasicObjectがあります**。これらのクラスやモジュールによって、オブジェクトとしての基礎となる動作が提供されています。
    - 親子のクラスで同名のメソッドを作った時の動作
        - 親クラスと同じ名前のメソッドを子クラスで書いた時、どちらが呼び出されるのでしょうか？プログラムを書いて確かめてみましょう。
        - 先ほど書いたItemクラスとDrinkクラスにfull_nameメソッドを作ります。full_nameメソッドは、Drinkクラスでは@nameと@sizeを合わせた名前を、Itemクラスでは@nameをそのまま返すことにします。

        ```ruby
        class Item # Itemという名前のクラスを作成せよ
          def name # 以下を実行するnameという名前のメソッドを作成せよ
            @name # インスタンス変数@name
          end # メソッド作成終了
          def name=(text) # 以下を実行する引数textを持つnameという名前のメソッドを作成せよ
            @name = text # 変数textをインスタンス変数@nameに紐付けせよ
          end # メソッド作成終了
          def full_name # 以下を実行するfull_nameという名前のメソッドを作成せよ
            @name # インスタンス変数@name
          end # メソッド作成終了
        end # クラス作成終了

        class Drink < Item # Itemクラスを継承するDrinkという名前のクラスを作成せよ
          def size # 以下を実行するsizeという名前のメソッドを作成せよ
            @size # インスタンス変数@size
          end # メソッド作成終了
          def size=(text) # 以下を実行する引数textを持つsizeという名前のメソッドを作成せよ
            @size = text # 変数textをインスタンス変数@sizeに紐付けせよ
          end # メソッド作成終了
          def full_name # 以下を実行するfull_nameという名前のメソッドを作成せよ
            "#{@name} #{@size}サイズ" # 文字列 "@name @sizeサイズ"
          end # メソッド作成終了
        end # クラス作成終了

        drink = Drink.new # Drinkクラスからオブジェクトを作成し、変数drinkに紐付けせよ
        drink.name = "カフェオレ" # 文字列 "カフェオレ" をdrinkオブジェクトから呼び出したnameメソッドに紐付けせよ
        drink.size = "tall" # 文字列 "tall" をdrinkオブジェクトから呼び出したsizeメソッドに紐付けせよ
        puts drink.full_name # drinkオブジェクトから呼び出したfull_nameを表示せよ => カフェオレ tallサイズ
        ```

        - Drinkクラスのオブジェクトに対してfull_nameメソッドを呼び出すと、Drinkクラスのfull_nameメソッドが呼び出されます。**親子のクラスで同名のメソッドがある時は自分のクラスのメソッドが呼ばれます**(**より正確にいうと、継承関係を親へ親へと辿っていって、最初に該当したメソッドを呼び出します**)。親クラスの同名メソッドは呼ばれず、覆い隠された形になります。
    - 親クラスのメソッドを呼び出す -super
        - 先程のitem4.rbでは、drinkクラスのオブジェクトでfull_nameメソッドを呼び出すと、Drinkクラスのメソッドが呼び出されました。**親クラスであるItemクラスのfull_nameメソッドは、子クラスであるDrinkクラスの同名メソッドで覆い隠されて呼び出されなくなりました**。これは上書きされたわけではなくて、呼び出しされなくなっているだけです。**Drinkクラスで親クラスItemのfull_nameメソッドを呼び出すこともできます**。
        - メソッド中で`super`と書くことで、**親クラスの同名メソッドを呼び出すことができます**。次のプログラムを見てみましょう。プログラムを見てみましょう。

        ```ruby
        class Item
          def name
            @name
          end
          def name=(text)
            @name = text
          end
          def full_name # ④
            @name
          end
        end

        class Drink < Item
          def size
            @size
          end
          def size=(text)
            @size
          end
          def full_name # ②
            super # ③
          end
        end

        drink = Drink.new
        drink.name = "カフェオレ"
        drink.size = "tall"
        puts drink.full_name #=> カフェオレ ①
        ```

        - このプログラムは`super`を使って、**Drinkクラスのfull_nameメソッドで親クラスItemのfull_nameメソッドを呼び出しています**。②で定義されたDrinkクラスのfull_nameメソッドを①で呼び出します。③で`super`を実行すると、親クラスの同名メソッドである④が呼び出されます。`super`は**親クラスの同名メソッドを呼び出して、戻り値を返します**。親クラスItemのfull_nameメソッドは@nameを返すので、①で表示されるのは"カフェオレ”となります。
        - また、superが戻り値を返すことを利用して、Drinkクラスのfull_nameメソッドの③の行を次のように書くと、1つ前のitem4.rbと同じ動作のプログラムになります。

        ```ruby
        "#{super} #{@size}サイズ" # ③の行を書き換えて、superを使って、item4.rbと同じ動作にする。
        ```

    - 📍まとめ
        - 子クラスは親クラスの全てのメソッドを受け継いで利用できる。
        - superを使うと親クラスの同盟メソッドを呼び出せる。
- 8-8 メソッドの呼び出しを制限する
    
    クラスのインスタンスメソッドは、クラス定義の外から呼び出したり、クラス定義の中から呼び出したりと、両方の呼び出し方ができました。メソッドの呼び出しを制限して、後者の「クラス定義の中で呼び出せる」だけに限定するメソッドを作ります。メソッド呼び出しを許可したり制限したりすることで、クラスの使い方を他のプログラマーへ伝えることができます。
    - クラスでのメソッド定義の中だけで呼び出せるメソッドを作る
        - これまでに作ってきたクラスのインスタンスメソッドは、先ず、クラス定義の外でレシーバに続けて呼び出すことができました。例えば、drink5.rbの`drink.name`の形です。
        - そして、別の呼び出し方として、クラス内のメソッド定義の中でレシーバを省略して呼び出すことができました。例えば、drink7.rbの`topping`の形です。
        - ここから、クラス定義の外でレシーバを指定した呼び出し方(前の例での`drink.name`)を制限することを考えます。つまり、後者であるクラスのメソッド定義の中からレシーバを省略して呼び出す形(前の例での`topping`)だけを許すようにします。
        - 今回の題材は「カフェでお客様用メソッドに加えて、店員ようメソッドを作る」です。

        ```ruby
        class Cafe
          def staff
            makanai # ①
          end
          def makanai
            "店員用スペシャルメニュー"
          end
        end

        cafe = Cafe.new
        puts cafe.staff #=> 店員用スペシャルメニュー
        puts cafe.makanai #=> 店員用スペシャルメニュー ②
        ```

        ```ruby
        店員用スペシャルメニュー
        店員用スペシャルメニュー
        ```

        - **staffメソッドの中で同じクラスのmakanaiメソッドを呼び出しています。cafe.staffでメソッドを呼び出すと、併せてmakanaiメソッドを呼び出します。**
        - 一方で、cafe.makanaiでもメソッドを呼び出すことができます。ここで、makanaiはスタッフしか注文できないので、Cafeクラスのメソッド定義の中から呼べないようにしてみましょう。つまり、この例では①のstaffメソッドの中でのmakanaiメソッド呼び出しはできるが、②のcafe.makanaiの呼び出しは禁止するようにします。
        - この用途のために`private`が用意されています。`private`を使うと、**レシーバを指定してのメソッド呼び出しを禁止するメソッドが定義できます**。次のプログラムを見てください。

        ```ruby
        class Cafe
          def staff
            makanai # ①
          end
          private # ③ 以降で定義するメソットをprivateなメソッドにする
          def makanai
            "店員用スペシャルメニュー"
          end
        end

        cafe = Cafe.new
        puts cafe.staff #=> 店員用スペシャルメニュー
        puts cafe.makanai # ②
        ```

        ```ruby
        店員用スペシャルメニュー
        private2.rb:13:in `<main>': private method `makanai' called for #<Cafe:0x000000010b365108> (NoMethodError)
        ```

        - ③のように、`private`をクラスに書くと、**クラスのそれ以降に定義したメソッドはprivateなメソッドになります**。**privateなmakanaiメソッドを、②のようにcafe.makanaiとレシーバを指定して呼び出そうとすると、意図通りエラーになります**。
        - **privateなmakanaiメソッドは、①のようにレシーバを指定しない方法では呼び出しできます**。**レシーバを書かないで呼び出せるのは、そのクラス定義内のインスタンスメソッドの中でしたね**。このように、**privateなメソッドを定義するとレシーバを省略できるところだけで呼び出せるので、結果的に、メソッドを呼び出すことができる場所をクラス定義の中だけに限定できます**。
        - 一方で、ここでのstaffメソッドのように、`cafe.staff`と**レシーバに続けて書いて呼び出せるメソッドをpublicなメソッドと言います**。**この形式は、クラス定義の外でも書くことができます**。
        - privateなメソッド、publicなメソッド

        |  | レシーバを書いた オブジェクト.メソッド名 形式での呼び出し | レシーバを書かない メソッド名 形式での呼び出し |
        | --- | --- | --- |
        | privateなメソッド | × | ◯ |
        | publicなメソッド | ◯ | ◯ |
        - 「クラス定義の外からレシーバを指定した形ではメソッドを呼ばせないようにする」という機能は、新しい機能を提供しているわけでもなく、できることを減らしているだけの、無意味なことにも思えるかもしれません。しかし、先程のプログラムではmakanaiメソッドを`private`にすることで、**「このクラスのオブジェクトでは、makanaiメソッドを使うのではなくて、staffメソッドを使ってくださいね」という設計上の意図を他のプログラマーへ伝えることができています。プログラムを通じて、作ったクラスとメソッドをそのオブジェクトらしく正しく使ってもらう方法を伝えている、大切な機能です。**
    - privateとpublic
        - `private`を使うと、**それ以降に定義したメソッドがprivateなメソッドになること**を説明しました。復習を兼ねて整理してみましょう。

        ```ruby
        class Foo
          def a # publicなメソッド
          end
          def b # publicなメソッド
          end

          private

          def c # privateなメソッド
          end
          def d # privateなメソッド
          end
        end

        # クラス内にprivateを書かずに定義したメソッドはpublicなメソッドになり、privateより後ろで定義したメソッドはprivateなメソッドになります。
        ```

        - この例では、aとbのメソッドはpublicなメソッド、cとdはprivateなメソッドになります。**クラス内にprivateを書かずに定義したメソッドはpublicなメソッド**になり、**privateより後ろで定義したメソッドはprivateなメソッド**になります。
        - privateを書いた後でpublicなメソッドを再び書きたい時のために、`public`も用意されています。**publicを書くと、以降に定義するメソッドはpublicなメソッドになります。**

        ```ruby
        class Foo
          def a # public
          end

          def b # public
          end

          private

          def c # private
          end

          public

          def d # public
          end
        end
        ```

        - a、b、dのメソッドがpublic、cのメソッドがprivateになります。privateとpublicは何度でも書くことができますが、**最初にpublicなメソッドをまとめて書き、その後にprivateなメソッドをまとめて書くことが一般的です。そのクラスの使い方を知る時にはpublicなメソッドを読む必要があるので、先頭に書いてあった方が都合が良いためです。**
        - また、privateをメソッド定義する`def`の前に書くことで、そのメソッドだけをprivateなメソッドにすることもできます。**次のプログラムではaメソッドだけをprivateなメソッドにしています。**

        ```ruby
        class Foo
          private def a # private
          end

          def b # public
          end
        end

        # privateをdefの前に書くことで、そのメソッドだけをprivateなメソッドにすることができます。
        ```

    - privateなクラスメソッドを定義する
        - self.メソッド名でクラスメソッドを定義できますが、この前にprivateを書いておいてもprivateなメソッドになりません。

        ```ruby
        class Foo
          private
          def self.a
            "method a"
          end
        end
        p Foo.a
        ```

        ```ruby
        "method a"
        ```

        - 代わりにメソッド定義のdefの前にprivate_class_methodと書きます。

        ```ruby
        class Foo
          private_class_method def self.a
            "method a"
          end
        end
        p Foo.a
        ```

        ```ruby
        private_class_mthod2.rb:6:in `<main>': private method `a' called for Foo:Class (NoMethodError)
        ```

        - また、前のコラムで紹介したclass << selfの書き方では、privateを使うことができます。
    - 📍まとめ
        - privateよりも後ろで定義したメソッドはprivateなメソッドになる。
        - **privateなメソッドはレシーバを指定したオブジェクト.メソッド名の形式で呼び出しができなくなる。**
        - **クラスの中でprivateより前またはprivateを書かずに定義したメソッド、およびpublicよりも後ろで定義したメソッドはpublicなメソッドになる。**
        - **publicなメソッドはオブジェクト.メソッド名の形式でも、レシーバを指定しないメソッド名の形式でも呼び出しができる。**</details>

**<details><summary>CHAPTER 9 部品を共同利用する - モジュール</summary>**
この章では、クラスとは違う仕組みでプログラムを整理して書く方法である「モジュール」を説明します。モジュールを使うとクラスとは違う仕組みの部品を作ることができます。この章を学ぶと、モジュールを利用してメソッドを共同利用する部品を作り、使うことができるようになります。
- 9-1 複数のクラスでメソッドを共同利用する
    
    モジュールを使うと、メソッドを共同利用することができます。ここでは、複数のクラスでメソッドを共同利用します。クラスにてモジュールをインクルードすることで、モジュールに定義したメソッドをあたかもクラス自身に定義されたメソッドとして使えるようにします。
    - メソッドを共同利用する手順
        - 題材として、ホイップクリームのトッピングを考えます。ホイップクリームはドリンクでもケーキでも楽しめるものですね。こんな場面でモジュールを使うと、ドリンクでもケーキでもトッピングできる部品を作ることができます。ホイップクリームをトッピングするメソッドを作り、メソッドを共同利用してみましょう。
        - 複数のクラスでメソッドを共同利用するには、次の3つの手順を行います。
            1. モジュールを作る
            2. モジュールにメソッドを定義する
            3. モジュールのメソッドをクラスで使う
    - モジュールを作る
        - **最初の手順はモジュールを作ることです。**ホイップクリームをトッピングする、`WhippedCream`という名前のモジュールを定義します。

        ```ruby
        module WhippedCream
        end
        ```

        ```ruby
        # 何も表示されません。
        ```

        - モジュールの定義

        ```ruby
        module モジュール名
        end
        ```

        - **モジュールの定義はクラスの定義と似ています**。モジュール名はクラス名と同じように、先頭を大文字から始めるキャメルケースで書きます。書式もクラスと似ていて、classをmoduleに置き換えて書きます。
        - モジュールはクラスと似ているものです。しかし、クラスと違ってインスタンスを作ることができません。主にメソッドを共同利用するための部品です。
    - モジュールにメソッドを定義する
        - **2つ目の手順はモジュールにメソッドを定義することです。**モジュールはクラスと同じように、インスタンスメソッドやクラスメソッド(正確にはモジュールメソッドですが、本書ではクラスメソッドに統一して書きます)を定義できます。引数や戻り値も同じように使えます。`WhippedCream`モジュールにインスタンスメソッドを定義してみましょう。ここではホイップクリームをトッピングする`whipped_cream`メソッドを定義します。

        ```ruby
        module WhippedCream
          def whipped_cream
            @name += "ホイップクリーム"
          end
        end
        ```

        ```ruby
        # 何も表示されません。
        ```

        - インスタンスメソッドwhipped_creamを呼ぶとインスタンス変数@nameの後ろに"ホイップクリーム”を追加します。module2.rbを実行しても何も表示されないのは、定義しただけではメソッドは実行されないからです。これはクラスの時と同じですね。
        - これで3つの手順のうちの2つが完了しました。次は最後の手順です。いよいよ動かすことができるようになります。
    - モジュールのメソッドをクラスで使う - include
        - できあがったWhippedCreamモジュールを早速使いたいところですが、その前にモジュールを使う側であるDrinkクラスを作っておきましょう。P.201のinitialize3.rbで書いたDrinkクラスを使うことにします。Drinkクラスは@nameを持っています。Drink.newでオブジェクトが作られたときに呼ばれるinitializeメソッドで、引数で渡した”モカ”が@nameに代入されます。

        ```ruby
        class Drink
          def initialize(name)
            @name = name
          end
          def name
            @name
          end
        end

        drink = Drink.new("モカ")
        puts drink.name
        ```

        ```ruby
        モカ
        ```

        - このDrinkクラスにて、WhippedCreamモジュールのwhipped_creamメソッドを使えるようにし、@nameの末尾に"ホイップクリーム”を加えるのがゴールです。
        - モジュールのメソッドをクラスで使えるようにするには、includeメソッドでモジュールを指定して、クラスにモジュールをインクルードします。
        - includeメソッド

        ```ruby
        class クラス名
            include モジュール名
        end
        ```

        ```ruby
        module WhippedCream
          def whipped_cream
            @name  += "ホイップクリーム" # ①
          end
        end

        class Drink
          include WhippedCream # ②
          def initialize(name)
            @name = name # ③
          end
          def name
            @name # ④
          end
        end

        drink = Drink.new("モカ") # ⑤
        drink.whipped_cream # ⑥
        puts drink.name # ⑦
        ```

        ```ruby
        モカホイップクリーム
        ```

        - ②のinclude WhippedCreamを実行すると、Drinkクラスのオブジェクトは、モジュールWhippedCreamのメソッド、ここではwhipped_creamが利用可能になります。⑥で実行しているdrink.whipped_creamは、WhippedCreamモジュールに定義したメソッドです。⑦でdrinkオブジェクトの@nameを表示すると、その前の行⑥でwhipped_creamメソッドが実行されているので、@nameは末尾にトッピングが追加された"モカホイップクリーム”になっています。
        - このプログラムではDrinkクラスのオブジェクトが持っている@nameが3箇所で使われています。@nameの動きに沿ってプログラムの流れをもう1回追いかけてみましょう。⑤のDrink.newメソッドの引数に"モカ”が渡され、③で@nameに代入されます。ここで作られたDrinkクラスのオブジェクト(@nameの持ち主です)は変数drinkに代入されます。次の行⑥でdrinkオブジェクトのwhipped_creamメソッドが呼び出され、①で@nameの末尾に"ホイップクリーム”が足されます。⑦で@nameを取得すると、"モカホイップクリーム”となっています。
        - また、先程のプログラムは、モジュールを使わずに書いた次のプログラムと同じ動作になります。

        ```ruby
        class Drink
          def whipped_cream
            @name += "ホイップクリーム"
          end
          def initialize(name)
            @name = name
          end
          def name
            @name
          end
        end

        drink = Drink.new("モカ")
        drink.whipped_cream
        puts drink.name
        ```

        ```ruby
        モカホイップクリーム
        ```

        - このようにクラスでincludeメソッドを使うと、引数で指定したモジュールのメソッドを、あたかもクラス自身のインスタンスメソッドとして使えるようになります。1つのクラスの中でincludeメソッドは何度でも呼べるので、複数のモジュールを同じクラスでインクルードして、それらのメソッドを利用することもできます。
    - モジュールは複数のクラスで共同利用できる
        - モジュールの優れたところは、複数のクラスで使えるところです。複数のクラスでモジュールをincludeすることで、そのモジュールのメソッドを共同利用できます。

        ```ruby
        module WhippedCream
          def whipped_cream
            @name += "ホイップクリーム"
          end
        end

        class Drink
          include WhippedCream
          def initialize(name)
            @name = name
          end
          def name
            @name
          end
        end

        class Cake
          include WhippedCream
          def initialize(name)
            @name = name
          end
          def name
            @name
          end
        end

        drink = Drink.new("モカ")
        drink.whipped_cream
        puts drink.name #=> モカホイップクリーム

        cake = Cake.new("チョコレートケーキ")
        cake.whipped_cream
        puts cake.name #=> チョコレートケーキホイップクリーム
        ```

        ```ruby
        モカホイップクリーム
        チョコレートケーキホイップクリーム
        ```

        - Drinkクラスの他に、ケーキを扱うCakeクラスを作りました。そして、Drinkクラスと同様に、CakeクラスでもWhippedCreamモジュールをインクルードします。WhippedCreamモジュールをインクルードすると、Drinkクラスだけでなく、Cakeクラスのオブジェクトでもwhipped_creamメソッドを呼び出せていますね。
        - このようにモジュールを使うと、クラスの継承とは違った形でメソッドを共同利用する仕組みを提供できます。前の章で説明したように、**継承を使うときには「(子クラスである)Drinkクラスは(親クラスである)Itemクラスの一種類である」という関係を持っていないと、違和感を感じる場合が多いです。モジュールではそのようなことは気にしなくてよいので、継承が適当でないなと思った場面でも選択肢として検討してみてください**。
    - COLUMN Enumerableモジュール
        - 配列に対して「全要素が該当しない」ことを調べるnone?メソッドがあります。

        ```ruby
        [1, 2].none?{ |x| x == 0} #=> true
        [1, 2].none?{ |x| x == 1} #=> false
        ```

        - リファレンスマニュアルには、none?メソッドはEnumerableモジュールのページに書いてあります。
        - EnumerableモジュールはArrayクラスにインクルードされていて、メソッド群を提供しています。none?メソッドもその1つです。Enumerableモジュールはリファレンスマニュアルを見るとわかるように、たくさんのメソッドが提供されるとても便利なモジュールです。配列ではEnumerableモジュールのメソッドも全て使えるということです。
        - Enumerableモジュールにはeachメソッドを使うメソッド群が定義されています。そのため、Enumerableモジュールを使うためには、インクルード元のクラスにeachメソッドが定義されている必要なあります。逆に言えば、自分で作ったクラスにeachメソッドを定義しておけば、Enumerableモジュールをインクルードすることで、たくさんのメソッド群を使うことができるという便利な仕組みになっています。
        - Rubyが用意しているクラスでは、他にも例えばHashクラスがeachメソッドを持っていて、Enumerableモジュールがインクルードされています。ハッシュでもEnumerableモジュールのメソッドを使うことができます。

        ```ruby
        {a: 1, b: 2}.none?{ |k,v| v == 0 } #=> true
        {a: 1, b: 2}.none?{ |k,v| v == 1 } #=> false
        ```
    
    - モジュールのメソッドをクラスメソッドにする - extend
        - extendメソッドをクラスで使うと、モジュールのメソッドをextend先のクラスのクラスメソッドとして使うことができます。クラスでincludeを使うとモジュールのメソッドをインスタンスメソッドとして利用できるようになりましたが、extendを使うとクラスメソッドとして利用できるようになります。
        - class_method1.rbをモジュールとextendを使って書くと、次のようになります。

        ```ruby
        module Greeting # ①
          def welcome # ②extendしたいメソッドをインスタンスメソッドとして定義
            "いらっしゃいませ！"
          end
        end
        class Cafe
          extend Greeting # ③
        end
        puts Cafe.welcome #=> いらっしゃいませ！ # ④
        ```

        - ①でextendメソッドで利用するモジュールを定義しています。②で利用したいクラスメソッドwelcomeをインスタンスメソッドとして定義します。インスタンスメソッドで定義することに注意してください。
        - ③でextendメソッドの引数にモジュールGreetingを渡すと、②で定義したwelcomeメソッドが、Cafeクラスのクラスメソッドとして利用可能になります。extendメソッドの書き方はincludeメソッドと同様、モジュールを引数として書きます。④で、そのCafeクラスのクラスメソッドwelcomeを呼び出しています。
    - 📍まとめ
        - モジュールを定義する

        ```ruby
        module モジュール名
        end
        ```

        - クラスにモジュールをインクルードする

        ```ruby
        class クラス名
            include モジュール名
        end
        ```

        - モジュールを使うとメソッドを共同利用することができる。
        - モジュールにはインスタンスメソッドを定義できる。
        - モジュールはクラスと違い、インスタンスを作ることはできない
        - クラスにモジュールをインクルードすると、モジュールに定義したインスタンスメソッドを利用できる。
        - eachメソッドを定義しているクラスで、Enumerableモジュールをインクルードするとメソッド群を利用できる。(eachメソッド:配列の前要素を繰り返し処理するメソッドのこと)
        - 配列やハッシュではEnumerableモジュールのメソッド群を利用できる。
- 9-2 モジュールのメソッドや定数をそのまま使う
    
    先程はモジュールのメソッドを複数のクラスで共同利用しました。モジュールの別の使い方として、定義したクラスメソッドや定数をそのまま使う方法もあります。
    
    - モジュールにクラスメソッドを定義する
        - モジュールにはインクルードしてメソッドを提供する使い方のほかに、クラスメソッドや定数を定義して呼び出す使い方があります。この使い方はクラスと同様です。

        ```ruby
        module WhippedCream
          def self.info # クラスメソッドを定義する時はメソッド名の前にself.を付ける。
            "トッピング用ホイップクリーム"
          end
        end
        puts WhippedCream.info #=> トッピング用ホイップクリーム
        ```

        - クラスメソッドinfoを定義して呼び出しています。定義の仕方も呼び出し方もクラスと同様です。クラスと比べると、モジュールはnewメソッドを使ってインスタンスを作ることができませんが、このようなクラスメソッドをまとめるときには、使い方に迷わないのでむしろ好都合です。
        - また、次のプログラムは定数を使う例です。定数は大文字で始めるルールでしたね。

        ```ruby
        module WhippedCream
          price = 100 # 定数priceに100を代入
        end
        puts WhippedCream::Price #=> 100
        ```

        - モジュールWhippedCreamの中で定義されている定数Priceを使うときには、このように`WhippedCream::Price`と`::`で繋げて書きます。
    - Rubyが用意しているモジュールを使う
        - ここまでは自分でモジュールを定義してきました。自分で定義するほかにも、Rubyが用意している便利なモジュールを使う方法もあります。Rubyが用意しているモジュールの例として、Mathモジュールを使ってみましょう。Mathモジュールにはsinやconなど数学計算用のクラスメソッドと、PI(円周率)などの定数が定義されています。

        ```ruby
        puts Math::PI #=> 3.141592653589793
        puts Math.cos(Math::PI) #=> -1.0
        ```

        - Mathモジュールの中の定数PIを使いたい時は、自分でモジュールを定義した時と同様に`Math::PI`と`::`で繋ぎます。
    - 名前空間
        - 同じクラス名を複数の場所で使いたいが、別のクラスなので別々に定義して呼び分けたい、というケースがあります。例えば、カフェごとに違うCoffeeクラスを作るケースを考えてみましょう。こんなときには、**モジュールを使って名前を付け分けるという手法があります**。これを「名前空間を作る」とも言います。

        ```ruby
        module BecoCafe
          class Coffee
            def self.info # クラスメソッドを定義する時はメソッド名の前にself.を付ける。
              "深みと香りのコーヒー"
            end
          end
        end
        module MachuCafe
          class Coffee
            def self.info
              "豊かな甘みのコーヒー"
            end
          end
        end
        puts BecoCafe::Coffee.info #=> 深みと香りのコーヒー
        puts MachuCafe::Coffee.info #=> 豊かな甘みのコーヒー
        ```

        - クラス名(またはモジュール名)の指定

        ```ruby
        クラス名(またはモジュール名)::クラス名(またはモジュール名)
        ```

        - これでそれぞれのCoffeeクラスは別のクラスとなりました。BecoCafe::CoffeeやMachuCafe::Coffeeのように`モジュール名::クラス名`と書くことでクラスを使い分けることができます。
        - モジュールやクラスを3つ以上繋げることもできます。また、プログラムで一番外側に書かれているクラスやモジュールは::BecoCafeや::BecoCafe::Coffeeのように、先頭に::を付けて書くこともできます。
        - このようなBecoCafeやMachuCafeを定義するには、クラスとモジュールのどちらも利用できますが、インスタンスを作る時はクラス、作らない時はモジュールを使うと意図が伝わりやすいでしょう。**名前空間を分けるだけであればインスタンスを作る必要がないので、モジュールを使うのがよいでしょう**。
    - 📍まとめ
        - モジュールにはクラスメソッド、定数を定義できる。
        - モジュールの中の定数を使う時は`::`でモジュール名と定数名を繋ぐ。
- 9-3 部品を別ファイルに分ける
    
    ここまででクラスやモジュールを部品として作る様々な方法を学んできました。これらの部品を整理して扱うために、クラスやモジュールを別のファイルに定義しておいて、読み込む仕組みが用意されています。この仕組みを使うと、整理して書けるだけでなく、複数のプログラム間で部品を共同利用することができるようになります。
    
    - 別ファイルのクラスやモジュールを読み込む
        - ここまでは1つのプログラムを1つのファイルに全て書いていましたが、プログラムの一部を別のファイルから読み込む仕組みも用意されています。
        - 題材として、DrinkクラスへWhippedCreamモジュールをインクルードしたプログラムを、WhippedCreamモジュールを別ファイルに保存して読み込むように書き換えてみましょう。プログラムとして、module4.rbを使います。module4.rbから、WhippedCreamモジュールを別のファイルへ移してみましょう。
        - 次の2つのプログラムを書いて、同じフォルダに保存してください。rubyコマンドで実行するのはdrink1.rbです。

        ```ruby
        require_relative "whipped_cream" # ①
        class Drink
          include WhippedCream
          def name
            @name
          end
          def initialize
            @name = "モカ"
          end
        end

        mocha = Drink.new
        mocha.whipped_cream
        puts mocha.name
        ```

        ```ruby
        モカホイップクリーム
        ```

        - WhippedCreamモジュールを別ファイルwhipped_cream.rbで定義しました。それを読み込んでdrink1.rbを実行します。結果は書き換える前と同じ「モカホイップクリーム」になっていますね。
        - whipped_cream.rbファイルを読み込んでいるのが①の行です。require_relativeメソッドの引数に文字列で、ファイル名(.rbは省略可能)を書きます。これでrequire_relativeメソッドを書いたプログラムファイル(ここではdrink1.rb)から、読み込んだファイル(ここではwhipped_cream.rb)で書かれた定義(ここではWhippedCreamモジュール)を使うことができます。rubyコマンドで実行するのは読み込んだ側であるdrink1.rbだけです。
        - モジュール定義だけでなく、クラス定義も別ファイルに書くことができます。別のファイルに書いておくと、整理できるだけでなく、複数のプログラムで読み込んで強要することができるメリットもあります。
        - 例えば、今回書いたwhipped_cream.rbをこれから書く新しいプログラムchocolate_cake.rbから読み込んで、そこでChocolateCakeクラスにWhippedCreamモジュールを使うこともできるわけです。
    - COLUMN require_relativeとrequire
        - 別のファイルを読み込む時に、require_relativeメソッドの代わりにrequireメソッドを使うこともできます。
        - 現在のフォルダにあるファイルであれば、先程の`require_relative “whipped_cream”`をrequireメソッドを使って書くと`require “./whipped_cream”`と書けます。
        - 別のファイルを読み込む時は、require_relativeメソッドを使うのがお勧めです。
        - requireメソッドは別の使い方もあります。
    - includeとrequire_relativeの違い
        - includeとrequire_relativeはどちらも「読み込む」という機能で似ているように感じますが、違う機能です。
        - includeはモジュール名を渡して、そのモジュールに書かれたメソッドをクラスから利用できるようにするメソッドです。require_relativeは、ファイル名を渡してそのファイルに定義されたクラスやモジュールを使えるようにするメソッドです。セットで使うことも多いこの2つですが、それぞれ機能が違います。
    - 📍まとめ
        - ファイルを読み込む。

        ```ruby
        require_relative "ファイル名"
        # .rbは省略可能。
        ```

        - require_relativeメソッドを使うと、別ファイルに定義されたクラスやモジュールを読み込んで使うことができる。</details>

**<details><summary>CHAPTER 10 Webアプリをつくる</summary>**
この章では、いろいろなプログラムで共有して使える便利な部品の使い方を学びます。そしてその部品を使って、Webアプリを作り、そこへアクセスするプログラムを書いてみましょう。この章を読み終わると、ネットで公開されているたくさんの道具を使うことができるようになり、書けるプログラムの範囲を大きく広げることができるでしょう。
- 10-1 ライブラリを使う
    
    いろいろなプログラムで共有して使える便利なプログラムをライブラリと呼びます。この節ではライブラリの使い方と、便利な管理の方法を説明します。
    
    - Gemとは
        - いろいろなプログラムで共有して使うプロフラムのことをライブラリと呼びます。Rubyの世界では大きく分けて3つのライブラリがあります。1つ目は何も準備せずに使える「組み込みライブラリ」、例えば、これまでによく使ってきたInteger、String、Array、Hashといったクラスたちです。2つ目は使う前にrequireメソッドを実行して準備する「標準添付ライブラリ」、例えば、JSONといったクラスです。3つ目は使う前にインストールが必要なGemと呼ばれるライブラリです。ここではGemについて説明していきます。
        - Gemは **[rubygems.org](http://rubygems.org)** というサイトで利用可能な形で公開されていて、10万を越えるGemが登録されています。それぞれのGemを使うことで、提供している機能を自分のプログラムで使うことができます。
    - Gemの使い方
        - ここでは例として、awesome_printというGemを使ってみましょう。このGemは、pメソッドをよりみやすい形で表示するapメソッドを提供します。**Gemを使うためには、先ずコマンドプロンプトでgem installコマンドに続いてGem名を指定してインストールします。**installは頭文字だけにしてgem iでも実行できます。awesome_printの場合は、`gem install awesome_print`となります。また、このコマンドの実行時にはネットワークへ接続が必要で、少し時間がかかります。
        - Gemのインストール
    
        ```ruby
        gem install Gem名
        ```

        ```ruby
        % gem install awesome_print
        Fetching awesome_print-1.9.2.gem
        Successfully installed awesome_print-1.9.2
        Parsing documentation for awesome_print-1.9.2
        Installing ri documentation for awesome_print-1.9.2
        Done installing documentation for awesome_print after 0 seconds
        1 gem installed
        ```

        - コマンドを実行すると、このような表示が出てGemがインストールされます。Gem名の後ろにハイフンで続く数字はバージョン番号です。実行した時の最新バージョンのGemがインストールされるため、バージョン番号は異なることもあります。
        - gem installコマンドでインストールするのは、1回だけで大丈夫です。プログラムを実行するごとにインストールする必要なありません(そして過去にインストール済みのGemインストールしても問題ないです)。インストールされたGemとそのバージョンは、コマンドプロンプトでgem listコマンドを実行すると確認することができます。
        - 尚、MacなどでERROR:    While executing gem ... (Gem::FilePermissionError) You don’体調は如何でしょうか？ have write permissions for ...というエラーとなることがあります。そのときは`sudo gem install awesome_print`と先頭に`sudo`を加えて実行してください。
        - インストールしたGemは通常、プログラムの中で、requireメソッドを実行することで利用可能になります。awesome_printの場合はrequire “awesome_print”を実行すると、それ以降でapメソッドを利用できるようになります。
    
        ```ruby
        require "awesome_print" # ① awesome_print gemを読み込み。
        ap ["カフェラテ", "モカ", "コーヒー"] # ② 
        ```

        ```ruby
        [
            [0] "カフェラテ",
            [1] "モカ",
            [2] "コーヒー"
        ]
        ```

        - ①の`require “awesome_print”`でawesome_print Gemを読み込みます。これは標準添付ライブラリの時と同様です。②でapメソッドを呼び出しています。**apメソッドの使い方はpメソッドと同様です。引数に渡したオブジェクトを見やすい形で表示します。**配列が要素ごとに見やすく表示されていますね。
        - Gemの使い方はGemごとに異なるため、Gem名で検索してドキュメントを読んでみてください。GitHubのページが用意されていることが多いです。
    - COLUMN たくさんのGemがある
        - さまざまなGemが公開されています。例えば、有名なRailsもWebアプリを簡単に作るためのライブラリ群で、複数のGemに整理されて公開されています。ほか、軽量なWebアプリをつくるためのライブラリSinatraや表示を見やすくしたirbの後発プログラムであるpryなど、たくさんのGemが公開されています。
    - Bundlerとは
        - Gemはgem installコマンドで簡単にインストールすることが可能ですが、この方法でたくさんのGemをインストールしようとすると、使うGemの数だけコマンドを打たなくてはいけません。それは大変なので、複数のGemを簡単に管理するBundlerという仕組みが用意されています。
        - BundlerでGem群をインストールするには2つの手順を踏みます。Gemfileの作成、bundle installコマンドの実行です。順に見ていきましょう。
    - NOTE
        - Bundlerはよく使われるため、Ruby 2.6.0から標準で添付されRubyと一緒にインストールされるようになりました。すでにインストールされているかを確認するには、コマンドプロンプトで`bundle -v`コマンドを実行して、バージョンが表示されれば、インストール済みです。またはBundlerもGemとして公開されているため、`gem list`コマンドでも確認できます。gem listコマンドの結果の中にbundlerが入っていればインストール済みです。もしもBundlerがインストールされていない時は、`gem install bundler`コマンドでインストールすることができます。
    - GemfileにインストールするGemを書く
        - 最初に、使用するGem群を書いたGemfileという名前のファイルを作成します。GemfileはBundlerを使ってインストールするGemのリストを書くファイルです。Gemfileは`bundle init`コマンドで雛形を作成し、そのファイルに使いたいGem名を追記します。仕組みの名前はBundlerですが、コマンド名は`bundle`と最後にrがつかない点に注意です。

        ```ruby
        yoshiwo@Yoshiwos-MacBook-Pro rubybook % bundle init
        Writing new Gemfile to /Users/yoshiwo/Desktop/rubybook/Gemfile

        # rubybookファイルに進んだ状態でbundle initコマンドを実行すること。
        ```

        - `/Users/yoshiwo/Desktop/rubybook/Gemfile`の部分はGemfileができた場所で、コマンドを実行したフォルダになります。できあがったGemfileをエディターで開いてみましょう。
        - Gemfile

        ```ruby
        # frozen_string_literal: true

        source "https://rubygems.org"

        # gem "rails"

        # テキスト3行目のgit_sourceがなかったので次で追加しました。
        ```

        ※テキストのGemfileの内容が一部ない。

        - 例として、pryというGemをGemfileに追記してみましょう。pryはirbの後発プログラムで、表示が見やすく、多くの機能を持っています。Gemfileの最後の行に使いたいGemを追記します。# gem “rails”は例として記載されているコメントなので、削除しても大丈夫です。
        - 以下のように編集します。
        - Gemfile

        ```ruby
        # frozen_string_literal: true

        source "https://rubygems.org"

        git_source(:github) {|repo_name| "https://github.com/#{repo_name}" } # bundle initでこの行が元からなかったので追加。

        gem "pry" # テキストの通りにこの行を追加。
        ```

    - bundle installコマンドでインストールする
        - 手順の2番目はbundle installコマンドを実行することです。Gemfileと同じフォルダへ移動してbundle installコマンドを実行します。または、省略してbundle i、またはbundleとも書けます。このコマンドの実行時にはネットワークへ接続が必要なため、少し時間が掛かります。

        ```ruby
        # desktop/rubybookファイルからbundle installコマンドを実行してインストールを行いました。
        yoshiwo@Yoshiwos-MacBook-Pro rubybook % bundle install
        Fetching gem metadata from https://rubygems.org/.......
        Resolving dependencies...
        Using bundler 2.3.3
        Fetching method_source 1.0.0
        Fetching coderay 1.1.3
        Installing method_source 1.0.0
        Installing coderay 1.1.3
        Fetching pry 0.14.1
        Installing pry 0.14.1
        Bundle complete! 1 Gemfile dependency, 4 gems now installed.
        Use `bundle info [gemname]` to see where a bundled gem is installed.
        ```

        - バージョン番号などが異なることがあります。また、インストール済みのGemがあると表示が変わりますが、問題はありません。
        - これでpry Gemがインストールされ、使う準備ができました。gem install pryを実行したことと同じことになります。コマンドプロンプトからpryコマンドを実行すると、irbのような表示がされ、入力したRubyのプログラムを1行ずつ実行することができます。pryを終了させるには、irbと同じく、`exit`と打ちます。
        - bundle installコマンドを実行すると、Gemfile.lockというファイルが作成されます。Gemfile.lockには、使われているGem名とそのバージョン情報などが記録されています。Gemfile.lockは自動で作られるものなので、編集する必要はありません。GemfileとGemfile.lockの2つのファイルはセットで使われるので、プログラムのファイル一式をバックアップする時などには、GemfileとGemfile.lockの両方を保管してください。
        - 2つのファイルを例え話で説明すると、GemfileはGemをインストールするための発注書です。**Gemfileに使いたいGem名を書いて、bundle installコマンドを実行すると、発注書に従ってGemがインストールされます。**Gemfile.lockは納品書です。**発注書に基づいて実際にインストールされたGemとそのバージョン情報などが書かれています。**
        - 公開されているRubyで書かれたプログラムにGemfileが添えられていた時にはbundle installコマンドを実行してからプログラムを実行してみましょう。多くの場合、ドキュメントでその旨が書かれていますが、慣れている人にとっては当たり前の動作でもあるので、ドキュメントで省略されている場合も時々あります。
    - COLUMN pry
        - pryには2つの使い方があり、どちらもirbと同様です。1つ目は対話型でコマンドプロンプトからpryコマンドで実行する方法。2つ目はプログラム中でrequire “pry”とbinding.pryの2行を書いて、そこで一時停止して、入力したプログラムを実行する方法です。P.61~63のirbについての説明を参考に使ってみてください。
    - bundle updateコマンドでGemをバージョンアップする
    
        Gemfileに書かれているGemに新しいバージョンがリリースされた時は、`bundle update`コマンドを使うことで新しいバージョンのGemをインストールできます。bundle updateコマンドを実行すると、Gemfile.lockが更新され、新たにインストールしたバージョンが書き込まれます。

        ```ruby
        bundle update
        ```
    
    - bundle execコマンドで指定したバージョンのGemを使う
        - 新しいバージョンのGemをインストールした時、古いバージョンのGemはアンインストールされないため、**同じGemの複数のバージョンがインストールされた状態になります**。通常は新しいバージョンが利用され、それで問題がないケースが多いのですが、Gemfile.lockに書かれたバージョンのGemを使って実行したいケースが時々あります。
        - そのような場合は、bundle execコマンドを使うことでGemfile.lockに書かれたGemバージョンでRubyのプログラムを実行することができます。rubyコマンドを実行する時に、その前に`bunndle exec`を書きます。

        ```ruby
        bundle exec ruby example.rb
        ```

    - 📍まとめ
        - Rubyでは、組み込みライブラリ、標準添付ライブラリ、Gemの三種類のライブラリがある。
        - `gem install Gem名`でGemをインストールできる。
        - 複数のGemを簡単に管理するBundlerが提供されている。
        - BundlerはGemfileという名のファイルに使うGem名を記述する。
        - `bundle install`コマンドを実行するとGemfileに書かれたGemがインストールされ、Gemfile.lockができる。
        - Gemfile.lockにはインストールされたGemとそのバージョンなどが書かれる。
        - `bundle update`コマンドを使うと利用中のGemの新しいバージョンがあればインストールされる。
        - `bundle exec`コマンドを使うとGemfileやGemfile.lockに書かれたGemバージョンでRubyのプログラムを実行する。
